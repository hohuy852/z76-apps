"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next-auth";
exports.ids = ["vendor-chunks/next-auth"];
exports.modules = {

/***/ "./node_modules/next-auth/index.js":
/*!*****************************************!*\
  !*** ./node_modules/next-auth/index.js ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthError: () => (/* reexport safe */ _auth_core_errors__WEBPACK_IMPORTED_MODULE_4__.AuthError),\n/* harmony export */   CredentialsSignin: () => (/* reexport safe */ _auth_core_errors__WEBPACK_IMPORTED_MODULE_4__.CredentialsSignin),\n/* harmony export */   customFetch: () => (/* reexport safe */ _auth_core__WEBPACK_IMPORTED_MODULE_0__.customFetch),\n/* harmony export */   \"default\": () => (/* binding */ NextAuth)\n/* harmony export */ });\n/* harmony import */ var _auth_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @auth/core */ \"@auth/core\");\n/* harmony import */ var _lib_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/env.js */ \"./node_modules/next-auth/lib/env.js\");\n/* harmony import */ var _lib_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/index.js */ \"./node_modules/next-auth/lib/index.js\");\n/* harmony import */ var _lib_actions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/actions.js */ \"./node_modules/next-auth/lib/actions.js\");\n/* harmony import */ var _auth_core_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @auth/core/errors */ \"@auth/core/errors\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_auth_core__WEBPACK_IMPORTED_MODULE_0__, _lib_env_js__WEBPACK_IMPORTED_MODULE_1__, _lib_index_js__WEBPACK_IMPORTED_MODULE_2__, _lib_actions_js__WEBPACK_IMPORTED_MODULE_3__, _auth_core_errors__WEBPACK_IMPORTED_MODULE_4__]);\n([_auth_core__WEBPACK_IMPORTED_MODULE_0__, _lib_env_js__WEBPACK_IMPORTED_MODULE_1__, _lib_index_js__WEBPACK_IMPORTED_MODULE_2__, _lib_actions_js__WEBPACK_IMPORTED_MODULE_3__, _auth_core_errors__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n/**\n * _If you are looking to migrate from v4, visit the [Upgrade Guide (v5)](https://authjs.dev/getting-started/migrating-to-v5)._\n *\n * ## Installation\n *\n * ```bash npm2yarn\n * npm install next-auth@beta\n * ```\n *\n * ## Environment variable inference\n *\n * `NEXTAUTH_URL` and `NEXTAUTH_SECRET` have been inferred since v4.\n *\n * Since NextAuth.js v5 can also automatically infer environment variables that are prefixed with `AUTH_`.\n *\n * For example `AUTH_GITHUB_ID` and `AUTH_GITHUB_SECRET` will be used as the `clientId` and `clientSecret` options for the GitHub provider.\n *\n * :::tip\n * The environment variable name inferring has the following format for OAuth providers: `AUTH_{PROVIDER}_{ID|SECRET}`.\n *\n * `PROVIDER` is the uppercase snake case version of the provider's id, followed by either `ID` or `SECRET` respectively.\n * :::\n *\n * `AUTH_SECRET` and `AUTH_URL` are also aliased for `NEXTAUTH_SECRET` and `NEXTAUTH_URL` for consistency.\n *\n * To add social login to your app, the configuration becomes:\n *\n * ```ts title=\"auth.ts\"\n * import NextAuth from \"next-auth\"\n * import GitHub from \"next-auth/providers/github\"\n * export const { handlers, auth } = NextAuth({ providers: [ GitHub ] })\n * ```\n *\n * And the `.env.local` file:\n *\n * ```sh title=\".env.local\"\n * AUTH_GITHUB_ID=...\n * AUTH_GITHUB_SECRET=...\n * AUTH_SECRET=...\n * ```\n *\n * :::tip\n * In production, `AUTH_SECRET` is a required environment variable - if not set, NextAuth.js will throw an error. See [MissingSecretError](https://authjs.dev/reference/core/errors#missingsecret) for more details.\n * :::\n *\n * If you need to override the default values for a provider, you can still call it as a function `GitHub({...})` as before.\n *\n * ## Lazy initialization\n * You can also initialize NextAuth.js lazily (previously known as advanced intialization), which allows you to access the request context in the configuration in some cases, like Route Handlers, Middleware, API Routes or `getServerSideProps`.\n * The above example becomes:\n *\n * ```ts title=\"auth.ts\"\n * import NextAuth from \"next-auth\"\n * import GitHub from \"next-auth/providers/github\"\n * export const { handlers, auth } = NextAuth(req => {\n *  if (req) {\n *   console.log(req) // do something with the request\n *  }\n *  return { providers: [ GitHub ] }\n * })\n * ```\n *\n * :::tip\n * This is useful if you want to customize the configuration based on the request, for example, to add a different provider in staging/dev environments.\n * :::\n *\n * @module next-auth\n */ \n\n\n\n\n\n/**\n *  Initialize NextAuth.js.\n *\n *  @example\n * ```ts title=\"auth.ts\"\n * import NextAuth from \"next-auth\"\n * import GitHub from \"@auth/core/providers/github\"\n *\n * export const { handlers, auth } = NextAuth({ providers: [GitHub] })\n * ```\n *\n * Lazy initialization:\n *\n * @example\n * ```ts title=\"auth.ts\"\n * import NextAuth from \"next-auth\"\n * import GitHub from \"@auth/core/providers/github\"\n *\n * export const { handlers, auth } = NextAuth(async (req) => {\n *   console.log(req) // do something with the request\n *   return {\n *     providers: [GitHub],\n *   },\n * })\n * ```\n */ function NextAuth(config) {\n    if (typeof config === \"function\") {\n        const httpHandler = async (req)=>{\n            const _config = await config(req);\n            (0,_lib_env_js__WEBPACK_IMPORTED_MODULE_1__.setEnvDefaults)(_config);\n            return (0,_auth_core__WEBPACK_IMPORTED_MODULE_0__.Auth)((0,_lib_env_js__WEBPACK_IMPORTED_MODULE_1__.reqWithEnvURL)(req), _config);\n        };\n        return {\n            handlers: {\n                GET: httpHandler,\n                POST: httpHandler\n            },\n            // @ts-expect-error\n            auth: (0,_lib_index_js__WEBPACK_IMPORTED_MODULE_2__.initAuth)(config, (c)=>(0,_lib_env_js__WEBPACK_IMPORTED_MODULE_1__.setEnvDefaults)(c)),\n            signIn: async (provider, options, authorizationParams)=>{\n                const _config = await config(undefined);\n                (0,_lib_env_js__WEBPACK_IMPORTED_MODULE_1__.setEnvDefaults)(_config);\n                return (0,_lib_actions_js__WEBPACK_IMPORTED_MODULE_3__.signIn)(provider, options, authorizationParams, _config);\n            },\n            signOut: async (options)=>{\n                const _config = await config(undefined);\n                (0,_lib_env_js__WEBPACK_IMPORTED_MODULE_1__.setEnvDefaults)(_config);\n                return (0,_lib_actions_js__WEBPACK_IMPORTED_MODULE_3__.signOut)(options, _config);\n            },\n            unstable_update: async (data)=>{\n                const _config = await config(undefined);\n                (0,_lib_env_js__WEBPACK_IMPORTED_MODULE_1__.setEnvDefaults)(_config);\n                return (0,_lib_actions_js__WEBPACK_IMPORTED_MODULE_3__.update)(data, _config);\n            }\n        };\n    }\n    (0,_lib_env_js__WEBPACK_IMPORTED_MODULE_1__.setEnvDefaults)(config);\n    const httpHandler = (req)=>(0,_auth_core__WEBPACK_IMPORTED_MODULE_0__.Auth)((0,_lib_env_js__WEBPACK_IMPORTED_MODULE_1__.reqWithEnvURL)(req), config);\n    return {\n        handlers: {\n            GET: httpHandler,\n            POST: httpHandler\n        },\n        // @ts-expect-error\n        auth: (0,_lib_index_js__WEBPACK_IMPORTED_MODULE_2__.initAuth)(config),\n        signIn: (provider, options, authorizationParams)=>{\n            return (0,_lib_actions_js__WEBPACK_IMPORTED_MODULE_3__.signIn)(provider, options, authorizationParams, config);\n        },\n        signOut: (options)=>{\n            return (0,_lib_actions_js__WEBPACK_IMPORTED_MODULE_3__.signOut)(options, config);\n        },\n        unstable_update: (data)=>{\n            return (0,_lib_actions_js__WEBPACK_IMPORTED_MODULE_3__.update)(data, config);\n        }\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUVDLEdBQzhDO0FBQ2M7QUFDbkI7QUFDaUI7QUFDTTtBQUMxQztBQUN2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNjLFNBQVNVLFNBQVNDLE1BQU07SUFDbkMsSUFBSSxPQUFPQSxXQUFXLFlBQVk7UUFDOUIsTUFBTUMsY0FBYyxPQUFPQztZQUN2QixNQUFNQyxVQUFVLE1BQU1ILE9BQU9FO1lBQzdCViwyREFBY0EsQ0FBQ1c7WUFDZixPQUFPZCxnREFBSUEsQ0FBQ0UsMERBQWFBLENBQUNXLE1BQU1DO1FBQ3BDO1FBQ0EsT0FBTztZQUNIQyxVQUFVO2dCQUFFQyxLQUFLSjtnQkFBYUssTUFBTUw7WUFBWTtZQUNoRCxtQkFBbUI7WUFDbkJNLE1BQU1kLHVEQUFRQSxDQUFDTyxRQUFRLENBQUNRLElBQU1oQiwyREFBY0EsQ0FBQ2dCO1lBQzdDZCxRQUFRLE9BQU9lLFVBQVVDLFNBQVNDO2dCQUM5QixNQUFNUixVQUFVLE1BQU1ILE9BQU9ZO2dCQUM3QnBCLDJEQUFjQSxDQUFDVztnQkFDZixPQUFPVCx1REFBTUEsQ0FBQ2UsVUFBVUMsU0FBU0MscUJBQXFCUjtZQUMxRDtZQUNBUixTQUFTLE9BQU9lO2dCQUNaLE1BQU1QLFVBQVUsTUFBTUgsT0FBT1k7Z0JBQzdCcEIsMkRBQWNBLENBQUNXO2dCQUNmLE9BQU9SLHdEQUFPQSxDQUFDZSxTQUFTUDtZQUM1QjtZQUNBVSxpQkFBaUIsT0FBT0M7Z0JBQ3BCLE1BQU1YLFVBQVUsTUFBTUgsT0FBT1k7Z0JBQzdCcEIsMkRBQWNBLENBQUNXO2dCQUNmLE9BQU9QLHVEQUFNQSxDQUFDa0IsTUFBTVg7WUFDeEI7UUFDSjtJQUNKO0lBQ0FYLDJEQUFjQSxDQUFDUTtJQUNmLE1BQU1DLGNBQWMsQ0FBQ0MsTUFBUWIsZ0RBQUlBLENBQUNFLDBEQUFhQSxDQUFDVyxNQUFNRjtJQUN0RCxPQUFPO1FBQ0hJLFVBQVU7WUFBRUMsS0FBS0o7WUFBYUssTUFBTUw7UUFBWTtRQUNoRCxtQkFBbUI7UUFDbkJNLE1BQU1kLHVEQUFRQSxDQUFDTztRQUNmTixRQUFRLENBQUNlLFVBQVVDLFNBQVNDO1lBQ3hCLE9BQU9qQix1REFBTUEsQ0FBQ2UsVUFBVUMsU0FBU0MscUJBQXFCWDtRQUMxRDtRQUNBTCxTQUFTLENBQUNlO1lBQ04sT0FBT2Ysd0RBQU9BLENBQUNlLFNBQVNWO1FBQzVCO1FBQ0FhLGlCQUFpQixDQUFDQztZQUNkLE9BQU9sQix1REFBTUEsQ0FBQ2tCLE1BQU1kO1FBQ3hCO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL2hvaHV5ODUyL0RvY3VtZW50cy96NzYtYXBwcy9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogX0lmIHlvdSBhcmUgbG9va2luZyB0byBtaWdyYXRlIGZyb20gdjQsIHZpc2l0IHRoZSBbVXBncmFkZSBHdWlkZSAodjUpXShodHRwczovL2F1dGhqcy5kZXYvZ2V0dGluZy1zdGFydGVkL21pZ3JhdGluZy10by12NSkuX1xuICpcbiAqICMjIEluc3RhbGxhdGlvblxuICpcbiAqIGBgYGJhc2ggbnBtMnlhcm5cbiAqIG5wbSBpbnN0YWxsIG5leHQtYXV0aEBiZXRhXG4gKiBgYGBcbiAqXG4gKiAjIyBFbnZpcm9ubWVudCB2YXJpYWJsZSBpbmZlcmVuY2VcbiAqXG4gKiBgTkVYVEFVVEhfVVJMYCBhbmQgYE5FWFRBVVRIX1NFQ1JFVGAgaGF2ZSBiZWVuIGluZmVycmVkIHNpbmNlIHY0LlxuICpcbiAqIFNpbmNlIE5leHRBdXRoLmpzIHY1IGNhbiBhbHNvIGF1dG9tYXRpY2FsbHkgaW5mZXIgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRoYXQgYXJlIHByZWZpeGVkIHdpdGggYEFVVEhfYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBgQVVUSF9HSVRIVUJfSURgIGFuZCBgQVVUSF9HSVRIVUJfU0VDUkVUYCB3aWxsIGJlIHVzZWQgYXMgdGhlIGBjbGllbnRJZGAgYW5kIGBjbGllbnRTZWNyZXRgIG9wdGlvbnMgZm9yIHRoZSBHaXRIdWIgcHJvdmlkZXIuXG4gKlxuICogOjo6dGlwXG4gKiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGUgbmFtZSBpbmZlcnJpbmcgaGFzIHRoZSBmb2xsb3dpbmcgZm9ybWF0IGZvciBPQXV0aCBwcm92aWRlcnM6IGBBVVRIX3tQUk9WSURFUn1fe0lEfFNFQ1JFVH1gLlxuICpcbiAqIGBQUk9WSURFUmAgaXMgdGhlIHVwcGVyY2FzZSBzbmFrZSBjYXNlIHZlcnNpb24gb2YgdGhlIHByb3ZpZGVyJ3MgaWQsIGZvbGxvd2VkIGJ5IGVpdGhlciBgSURgIG9yIGBTRUNSRVRgIHJlc3BlY3RpdmVseS5cbiAqIDo6OlxuICpcbiAqIGBBVVRIX1NFQ1JFVGAgYW5kIGBBVVRIX1VSTGAgYXJlIGFsc28gYWxpYXNlZCBmb3IgYE5FWFRBVVRIX1NFQ1JFVGAgYW5kIGBORVhUQVVUSF9VUkxgIGZvciBjb25zaXN0ZW5jeS5cbiAqXG4gKiBUbyBhZGQgc29jaWFsIGxvZ2luIHRvIHlvdXIgYXBwLCB0aGUgY29uZmlndXJhdGlvbiBiZWNvbWVzOlxuICpcbiAqIGBgYHRzIHRpdGxlPVwiYXV0aC50c1wiXG4gKiBpbXBvcnQgTmV4dEF1dGggZnJvbSBcIm5leHQtYXV0aFwiXG4gKiBpbXBvcnQgR2l0SHViIGZyb20gXCJuZXh0LWF1dGgvcHJvdmlkZXJzL2dpdGh1YlwiXG4gKiBleHBvcnQgY29uc3QgeyBoYW5kbGVycywgYXV0aCB9ID0gTmV4dEF1dGgoeyBwcm92aWRlcnM6IFsgR2l0SHViIF0gfSlcbiAqIGBgYFxuICpcbiAqIEFuZCB0aGUgYC5lbnYubG9jYWxgIGZpbGU6XG4gKlxuICogYGBgc2ggdGl0bGU9XCIuZW52LmxvY2FsXCJcbiAqIEFVVEhfR0lUSFVCX0lEPS4uLlxuICogQVVUSF9HSVRIVUJfU0VDUkVUPS4uLlxuICogQVVUSF9TRUNSRVQ9Li4uXG4gKiBgYGBcbiAqXG4gKiA6Ojp0aXBcbiAqIEluIHByb2R1Y3Rpb24sIGBBVVRIX1NFQ1JFVGAgaXMgYSByZXF1aXJlZCBlbnZpcm9ubWVudCB2YXJpYWJsZSAtIGlmIG5vdCBzZXQsIE5leHRBdXRoLmpzIHdpbGwgdGhyb3cgYW4gZXJyb3IuIFNlZSBbTWlzc2luZ1NlY3JldEVycm9yXShodHRwczovL2F1dGhqcy5kZXYvcmVmZXJlbmNlL2NvcmUvZXJyb3JzI21pc3NpbmdzZWNyZXQpIGZvciBtb3JlIGRldGFpbHMuXG4gKiA6OjpcbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCB2YWx1ZXMgZm9yIGEgcHJvdmlkZXIsIHlvdSBjYW4gc3RpbGwgY2FsbCBpdCBhcyBhIGZ1bmN0aW9uIGBHaXRIdWIoey4uLn0pYCBhcyBiZWZvcmUuXG4gKlxuICogIyMgTGF6eSBpbml0aWFsaXphdGlvblxuICogWW91IGNhbiBhbHNvIGluaXRpYWxpemUgTmV4dEF1dGguanMgbGF6aWx5IChwcmV2aW91c2x5IGtub3duIGFzIGFkdmFuY2VkIGludGlhbGl6YXRpb24pLCB3aGljaCBhbGxvd3MgeW91IHRvIGFjY2VzcyB0aGUgcmVxdWVzdCBjb250ZXh0IGluIHRoZSBjb25maWd1cmF0aW9uIGluIHNvbWUgY2FzZXMsIGxpa2UgUm91dGUgSGFuZGxlcnMsIE1pZGRsZXdhcmUsIEFQSSBSb3V0ZXMgb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gKiBUaGUgYWJvdmUgZXhhbXBsZSBiZWNvbWVzOlxuICpcbiAqIGBgYHRzIHRpdGxlPVwiYXV0aC50c1wiXG4gKiBpbXBvcnQgTmV4dEF1dGggZnJvbSBcIm5leHQtYXV0aFwiXG4gKiBpbXBvcnQgR2l0SHViIGZyb20gXCJuZXh0LWF1dGgvcHJvdmlkZXJzL2dpdGh1YlwiXG4gKiBleHBvcnQgY29uc3QgeyBoYW5kbGVycywgYXV0aCB9ID0gTmV4dEF1dGgocmVxID0+IHtcbiAqICBpZiAocmVxKSB7XG4gKiAgIGNvbnNvbGUubG9nKHJlcSkgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlcXVlc3RcbiAqICB9XG4gKiAgcmV0dXJuIHsgcHJvdmlkZXJzOiBbIEdpdEh1YiBdIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiA6Ojp0aXBcbiAqIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGN1c3RvbWl6ZSB0aGUgY29uZmlndXJhdGlvbiBiYXNlZCBvbiB0aGUgcmVxdWVzdCwgZm9yIGV4YW1wbGUsIHRvIGFkZCBhIGRpZmZlcmVudCBwcm92aWRlciBpbiBzdGFnaW5nL2RldiBlbnZpcm9ubWVudHMuXG4gKiA6OjpcbiAqXG4gKiBAbW9kdWxlIG5leHQtYXV0aFxuICovXG5pbXBvcnQgeyBBdXRoLCBjdXN0b21GZXRjaCB9IGZyb20gXCJAYXV0aC9jb3JlXCI7XG5pbXBvcnQgeyByZXFXaXRoRW52VVJMLCBzZXRFbnZEZWZhdWx0cyB9IGZyb20gXCIuL2xpYi9lbnYuanNcIjtcbmltcG9ydCB7IGluaXRBdXRoIH0gZnJvbSBcIi4vbGliL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBzaWduSW4sIHNpZ25PdXQsIHVwZGF0ZSB9IGZyb20gXCIuL2xpYi9hY3Rpb25zLmpzXCI7XG5leHBvcnQgeyBBdXRoRXJyb3IsIENyZWRlbnRpYWxzU2lnbmluIH0gZnJvbSBcIkBhdXRoL2NvcmUvZXJyb3JzXCI7XG5leHBvcnQgeyBjdXN0b21GZXRjaCB9O1xuLyoqXG4gKiAgSW5pdGlhbGl6ZSBOZXh0QXV0aC5qcy5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqIGBgYHRzIHRpdGxlPVwiYXV0aC50c1wiXG4gKiBpbXBvcnQgTmV4dEF1dGggZnJvbSBcIm5leHQtYXV0aFwiXG4gKiBpbXBvcnQgR2l0SHViIGZyb20gXCJAYXV0aC9jb3JlL3Byb3ZpZGVycy9naXRodWJcIlxuICpcbiAqIGV4cG9ydCBjb25zdCB7IGhhbmRsZXJzLCBhdXRoIH0gPSBOZXh0QXV0aCh7IHByb3ZpZGVyczogW0dpdEh1Yl0gfSlcbiAqIGBgYFxuICpcbiAqIExhenkgaW5pdGlhbGl6YXRpb246XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHRpdGxlPVwiYXV0aC50c1wiXG4gKiBpbXBvcnQgTmV4dEF1dGggZnJvbSBcIm5leHQtYXV0aFwiXG4gKiBpbXBvcnQgR2l0SHViIGZyb20gXCJAYXV0aC9jb3JlL3Byb3ZpZGVycy9naXRodWJcIlxuICpcbiAqIGV4cG9ydCBjb25zdCB7IGhhbmRsZXJzLCBhdXRoIH0gPSBOZXh0QXV0aChhc3luYyAocmVxKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHJlcSkgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlcXVlc3RcbiAqICAgcmV0dXJuIHtcbiAqICAgICBwcm92aWRlcnM6IFtHaXRIdWJdLFxuICogICB9LFxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBOZXh0QXV0aChjb25maWcpIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IGh0dHBIYW5kbGVyID0gYXN5bmMgKHJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgX2NvbmZpZyA9IGF3YWl0IGNvbmZpZyhyZXEpO1xuICAgICAgICAgICAgc2V0RW52RGVmYXVsdHMoX2NvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm4gQXV0aChyZXFXaXRoRW52VVJMKHJlcSksIF9jb25maWcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFuZGxlcnM6IHsgR0VUOiBodHRwSGFuZGxlciwgUE9TVDogaHR0cEhhbmRsZXIgfSxcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGF1dGg6IGluaXRBdXRoKGNvbmZpZywgKGMpID0+IHNldEVudkRlZmF1bHRzKGMpKSxcbiAgICAgICAgICAgIHNpZ25JbjogYXN5bmMgKHByb3ZpZGVyLCBvcHRpb25zLCBhdXRob3JpemF0aW9uUGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2NvbmZpZyA9IGF3YWl0IGNvbmZpZyh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHNldEVudkRlZmF1bHRzKF9jb25maWcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduSW4ocHJvdmlkZXIsIG9wdGlvbnMsIGF1dGhvcml6YXRpb25QYXJhbXMsIF9jb25maWcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZ25PdXQ6IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2NvbmZpZyA9IGF3YWl0IGNvbmZpZyh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHNldEVudkRlZmF1bHRzKF9jb25maWcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduT3V0KG9wdGlvbnMsIF9jb25maWcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc3RhYmxlX3VwZGF0ZTogYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfY29uZmlnID0gYXdhaXQgY29uZmlnKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgc2V0RW52RGVmYXVsdHMoX2NvbmZpZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZShkYXRhLCBfY29uZmlnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldEVudkRlZmF1bHRzKGNvbmZpZyk7XG4gICAgY29uc3QgaHR0cEhhbmRsZXIgPSAocmVxKSA9PiBBdXRoKHJlcVdpdGhFbnZVUkwocmVxKSwgY29uZmlnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYW5kbGVyczogeyBHRVQ6IGh0dHBIYW5kbGVyLCBQT1NUOiBodHRwSGFuZGxlciB9LFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGF1dGg6IGluaXRBdXRoKGNvbmZpZyksXG4gICAgICAgIHNpZ25JbjogKHByb3ZpZGVyLCBvcHRpb25zLCBhdXRob3JpemF0aW9uUGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc2lnbkluKHByb3ZpZGVyLCBvcHRpb25zLCBhdXRob3JpemF0aW9uUGFyYW1zLCBjb25maWcpO1xuICAgICAgICB9LFxuICAgICAgICBzaWduT3V0OiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNpZ25PdXQob3B0aW9ucywgY29uZmlnKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zdGFibGVfdXBkYXRlOiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZShkYXRhLCBjb25maWcpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4iXSwibmFtZXMiOlsiQXV0aCIsImN1c3RvbUZldGNoIiwicmVxV2l0aEVudlVSTCIsInNldEVudkRlZmF1bHRzIiwiaW5pdEF1dGgiLCJzaWduSW4iLCJzaWduT3V0IiwidXBkYXRlIiwiQXV0aEVycm9yIiwiQ3JlZGVudGlhbHNTaWduaW4iLCJOZXh0QXV0aCIsImNvbmZpZyIsImh0dHBIYW5kbGVyIiwicmVxIiwiX2NvbmZpZyIsImhhbmRsZXJzIiwiR0VUIiwiUE9TVCIsImF1dGgiLCJjIiwicHJvdmlkZXIiLCJvcHRpb25zIiwiYXV0aG9yaXphdGlvblBhcmFtcyIsInVuZGVmaW5lZCIsInVuc3RhYmxlX3VwZGF0ZSIsImRhdGEiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next-auth/index.js\n");

/***/ }),

/***/ "./node_modules/next-auth/lib/actions.js":
/*!***********************************************!*\
  !*** ./node_modules/next-auth/lib/actions.js ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   signIn: () => (/* binding */ signIn),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\n/* harmony import */ var _auth_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @auth/core */ \"@auth/core\");\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/headers */ \"./node_modules/next/headers.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"./node_modules/next/navigation.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_auth_core__WEBPACK_IMPORTED_MODULE_0__]);\n_auth_core__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n// @ts-expect-error Next.js does not yet correctly use the `package.json#exports` field\n\n// @ts-expect-error Next.js does not yet correctly use the `package.json#exports` field\n\nasync function signIn(provider, options = {}, authorizationParams, config) {\n    const headers = new Headers(await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.headers)());\n    const { redirect: shouldRedirect = true, redirectTo, ...rest } = options instanceof FormData ? Object.fromEntries(options) : options;\n    const callbackUrl = redirectTo?.toString() ?? headers.get(\"Referer\") ?? \"/\";\n    const signInURL = (0,_auth_core__WEBPACK_IMPORTED_MODULE_0__.createActionURL)(\"signin\", // @ts-expect-error `x-forwarded-proto` is not nullable, next.js sets it by default\n    headers.get(\"x-forwarded-proto\"), headers, process.env, config);\n    if (!provider) {\n        signInURL.searchParams.append(\"callbackUrl\", callbackUrl);\n        if (shouldRedirect) (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.redirect)(signInURL.toString());\n        return signInURL.toString();\n    }\n    let url = `${signInURL}/${provider}?${new URLSearchParams(authorizationParams)}`;\n    let foundProvider = {};\n    for (const providerConfig of config.providers){\n        const { options, ...defaults } = typeof providerConfig === \"function\" ? providerConfig() : providerConfig;\n        const id = options?.id ?? defaults.id;\n        if (id === provider) {\n            foundProvider = {\n                id,\n                type: options?.type ?? defaults.type\n            };\n            break;\n        }\n    }\n    if (!foundProvider.id) {\n        const url = `${signInURL}?${new URLSearchParams({\n            callbackUrl\n        })}`;\n        if (shouldRedirect) (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.redirect)(url);\n        return url;\n    }\n    if (foundProvider.type === \"credentials\") {\n        url = url.replace(\"signin\", \"callback\");\n    }\n    headers.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    const body = new URLSearchParams({\n        ...rest,\n        callbackUrl\n    });\n    const req = new Request(url, {\n        method: \"POST\",\n        headers,\n        body\n    });\n    const res = await (0,_auth_core__WEBPACK_IMPORTED_MODULE_0__.Auth)(req, {\n        ...config,\n        raw: _auth_core__WEBPACK_IMPORTED_MODULE_0__.raw,\n        skipCSRFCheck: _auth_core__WEBPACK_IMPORTED_MODULE_0__.skipCSRFCheck\n    });\n    const cookieJar = await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies)();\n    for (const c of res?.cookies ?? [])cookieJar.set(c.name, c.value, c.options);\n    const responseUrl = res instanceof Response ? res.headers.get(\"Location\") : res.redirect;\n    // NOTE: if for some unexpected reason the responseUrl is not set,\n    // we redirect to the original url\n    const redirectUrl = responseUrl ?? url;\n    if (shouldRedirect) return (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.redirect)(redirectUrl);\n    return redirectUrl;\n}\nasync function signOut(options, config) {\n    const headers = new Headers(await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.headers)());\n    headers.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    const url = (0,_auth_core__WEBPACK_IMPORTED_MODULE_0__.createActionURL)(\"signout\", // @ts-expect-error `x-forwarded-proto` is not nullable, next.js sets it by default\n    headers.get(\"x-forwarded-proto\"), headers, process.env, config);\n    const callbackUrl = options?.redirectTo ?? headers.get(\"Referer\") ?? \"/\";\n    const body = new URLSearchParams({\n        callbackUrl\n    });\n    const req = new Request(url, {\n        method: \"POST\",\n        headers,\n        body\n    });\n    const res = await (0,_auth_core__WEBPACK_IMPORTED_MODULE_0__.Auth)(req, {\n        ...config,\n        raw: _auth_core__WEBPACK_IMPORTED_MODULE_0__.raw,\n        skipCSRFCheck: _auth_core__WEBPACK_IMPORTED_MODULE_0__.skipCSRFCheck\n    });\n    const cookieJar = await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies)();\n    for (const c of res?.cookies ?? [])cookieJar.set(c.name, c.value, c.options);\n    if (options?.redirect ?? true) return (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.redirect)(res.redirect);\n    return res;\n}\nasync function update(data, config) {\n    const headers = new Headers(await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.headers)());\n    headers.set(\"Content-Type\", \"application/json\");\n    const url = (0,_auth_core__WEBPACK_IMPORTED_MODULE_0__.createActionURL)(\"session\", // @ts-expect-error `x-forwarded-proto` is not nullable, next.js sets it by default\n    headers.get(\"x-forwarded-proto\"), headers, process.env, config);\n    const body = JSON.stringify({\n        data\n    });\n    const req = new Request(url, {\n        method: \"POST\",\n        headers,\n        body\n    });\n    const res = await (0,_auth_core__WEBPACK_IMPORTED_MODULE_0__.Auth)(req, {\n        ...config,\n        raw: _auth_core__WEBPACK_IMPORTED_MODULE_0__.raw,\n        skipCSRFCheck: _auth_core__WEBPACK_IMPORTED_MODULE_0__.skipCSRFCheck\n    });\n    const cookieJar = await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies)();\n    for (const c of res?.cookies ?? [])cookieJar.set(c.name, c.value, c.options);\n    return res.body;\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2xpYi9hY3Rpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF1RTtBQUN2RSx1RkFBdUY7QUFDeEI7QUFDL0QsdUZBQXVGO0FBQzVDO0FBQ3BDLGVBQWVRLE9BQU9DLFFBQVEsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUMsbUJBQW1CLEVBQUVDLE1BQU07SUFDNUUsTUFBTVIsVUFBVSxJQUFJUyxRQUFRLE1BQU1SLHFEQUFXQTtJQUM3QyxNQUFNLEVBQUVFLFVBQVVPLGlCQUFpQixJQUFJLEVBQUVDLFVBQVUsRUFBRSxHQUFHQyxNQUFNLEdBQUdOLG1CQUFtQk8sV0FBV0MsT0FBT0MsV0FBVyxDQUFDVCxXQUFXQTtJQUM3SCxNQUFNVSxjQUFjTCxZQUFZTSxjQUFjakIsUUFBUWtCLEdBQUcsQ0FBQyxjQUFjO0lBQ3hFLE1BQU1DLFlBQVlwQiwyREFBZUEsQ0FBQyxVQUNsQyxtRkFBbUY7SUFDbkZDLFFBQVFrQixHQUFHLENBQUMsc0JBQXNCbEIsU0FBU29CLFFBQVFDLEdBQUcsRUFBRWI7SUFDeEQsSUFBSSxDQUFDSCxVQUFVO1FBQ1hjLFVBQVVHLFlBQVksQ0FBQ0MsTUFBTSxDQUFDLGVBQWVQO1FBQzdDLElBQUlOLGdCQUNBUCx5REFBUUEsQ0FBQ2dCLFVBQVVGLFFBQVE7UUFDL0IsT0FBT0UsVUFBVUYsUUFBUTtJQUM3QjtJQUNBLElBQUlPLE1BQU0sR0FBR0wsVUFBVSxDQUFDLEVBQUVkLFNBQVMsQ0FBQyxFQUFFLElBQUlvQixnQkFBZ0JsQixzQkFBc0I7SUFDaEYsSUFBSW1CLGdCQUFnQixDQUFDO0lBQ3JCLEtBQUssTUFBTUMsa0JBQWtCbkIsT0FBT29CLFNBQVMsQ0FBRTtRQUMzQyxNQUFNLEVBQUV0QixPQUFPLEVBQUUsR0FBR3VCLFVBQVUsR0FBRyxPQUFPRixtQkFBbUIsYUFBYUEsbUJBQW1CQTtRQUMzRixNQUFNRyxLQUFLeEIsU0FBU3dCLE1BQU1ELFNBQVNDLEVBQUU7UUFDckMsSUFB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O0lBQ3hELE1BQU0wQixPQUFPZSxLQUFLQyxTQUFTLENBQUM7UUFBRUY7SUFBSztJQUNuQyxNQUFNYixNQUFNLElBQUlDLFFBQVFaLEtBQUs7UUFBRWEsUUFBUTtRQUFRckM7UUFBU2tDO0lBQUs7SUFDN0QsTUFBTUksTUFBTSxNQUFNMUMsZ0RBQUlBLENBQUN1QyxLQUFLO1FBQUUsR0FBRzNCLE1BQU07UUFBRVgsR0FBR0EsNkNBQUFBO1FBQUVDLGFBQWFBLHVEQUFBQTtJQUFDO0lBQzVELE1BQU15QyxZQUFZLE1BQU1yQyxxREFBT0E7SUFDL0IsS0FBSyxNQUFNc0MsS0FBS0YsS0FBS3BDLFdBQVcsRUFBRSxDQUM5QnFDLFVBQVVOLEdBQUcsQ0FBQ08sRUFBRUMsSUFBSSxFQUFFRCxFQUFFRSxLQUFLLEVBQUVGLEVBQUVsQyxPQUFPO0lBQzVDLE9BQU9nQyxJQUFJSixJQUFJO0FBQ25CIiwic291cmNlcyI6WyIvVXNlcnMvaG9odXk4NTIvRG9jdW1lbnRzL3o3Ni1hcHBzL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvbGliL2FjdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXV0aCwgcmF3LCBza2lwQ1NSRkNoZWNrLCBjcmVhdGVBY3Rpb25VUkwgfSBmcm9tIFwiQGF1dGgvY29yZVwiO1xuLy8gQHRzLWV4cGVjdC1lcnJvciBOZXh0LmpzIGRvZXMgbm90IHlldCBjb3JyZWN0bHkgdXNlIHRoZSBgcGFja2FnZS5qc29uI2V4cG9ydHNgIGZpZWxkXG5pbXBvcnQgeyBoZWFkZXJzIGFzIG5leHRIZWFkZXJzLCBjb29raWVzIH0gZnJvbSBcIm5leHQvaGVhZGVyc1wiO1xuLy8gQHRzLWV4cGVjdC1lcnJvciBOZXh0LmpzIGRvZXMgbm90IHlldCBjb3JyZWN0bHkgdXNlIHRoZSBgcGFja2FnZS5qc29uI2V4cG9ydHNgIGZpZWxkXG5pbXBvcnQgeyByZWRpcmVjdCB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW4ocHJvdmlkZXIsIG9wdGlvbnMgPSB7fSwgYXV0aG9yaXphdGlvblBhcmFtcywgY29uZmlnKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGF3YWl0IG5leHRIZWFkZXJzKCkpO1xuICAgIGNvbnN0IHsgcmVkaXJlY3Q6IHNob3VsZFJlZGlyZWN0ID0gdHJ1ZSwgcmVkaXJlY3RUbywgLi4ucmVzdCB9ID0gb3B0aW9ucyBpbnN0YW5jZW9mIEZvcm1EYXRhID8gT2JqZWN0LmZyb21FbnRyaWVzKG9wdGlvbnMpIDogb3B0aW9ucztcbiAgICBjb25zdCBjYWxsYmFja1VybCA9IHJlZGlyZWN0VG8/LnRvU3RyaW5nKCkgPz8gaGVhZGVycy5nZXQoXCJSZWZlcmVyXCIpID8/IFwiL1wiO1xuICAgIGNvbnN0IHNpZ25JblVSTCA9IGNyZWF0ZUFjdGlvblVSTChcInNpZ25pblwiLCBcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGB4LWZvcndhcmRlZC1wcm90b2AgaXMgbm90IG51bGxhYmxlLCBuZXh0LmpzIHNldHMgaXQgYnkgZGVmYXVsdFxuICAgIGhlYWRlcnMuZ2V0KFwieC1mb3J3YXJkZWQtcHJvdG9cIiksIGhlYWRlcnMsIHByb2Nlc3MuZW52LCBjb25maWcpO1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgc2lnbkluVVJMLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJjYWxsYmFja1VybFwiLCBjYWxsYmFja1VybCk7XG4gICAgICAgIGlmIChzaG91bGRSZWRpcmVjdClcbiAgICAgICAgICAgIHJlZGlyZWN0KHNpZ25JblVSTC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHNpZ25JblVSTC50b1N0cmluZygpO1xuICAgIH1cbiAgICBsZXQgdXJsID0gYCR7c2lnbkluVVJMfS8ke3Byb3ZpZGVyfT8ke25ldyBVUkxTZWFyY2hQYXJhbXMoYXV0aG9yaXphdGlvblBhcmFtcyl9YDtcbiAgICBsZXQgZm91bmRQcm92aWRlciA9IHt9O1xuICAgIGZvciAoY29uc3QgcHJvdmlkZXJDb25maWcgb2YgY29uZmlnLnByb3ZpZGVycykge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMsIC4uLmRlZmF1bHRzIH0gPSB0eXBlb2YgcHJvdmlkZXJDb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IHByb3ZpZGVyQ29uZmlnKCkgOiBwcm92aWRlckNvbmZpZztcbiAgICAgICAgY29uc3QgaWQgPSBvcHRpb25zPy5pZCA/PyBkZWZhdWx0cy5pZDtcbiAgICAgICAgaWYgKGlkID09PSBwcm92aWRlcikge1xuICAgICAgICAgICAgZm91bmRQcm92aWRlciA9IHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBvcHRpb25zPy50eXBlID8/IGRlZmF1bHRzLnR5cGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3VuZFByb3ZpZGVyLmlkKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3NpZ25JblVSTH0/JHtuZXcgVVJMU2VhcmNoUGFyYW1zKHsgY2FsbGJhY2tVcmwgfSl9YDtcbiAgICAgICAgaWYgKHNob3VsZFJlZGlyZWN0KVxuICAgICAgICAgICAgcmVkaXJlY3QodXJsKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgaWYgKGZvdW5kUHJvdmlkZXIudHlwZSA9PT0gXCJjcmVkZW50aWFsc1wiKSB7XG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFwic2lnbmluXCIsIFwiY2FsbGJhY2tcIik7XG4gICAgfVxuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgLi4ucmVzdCwgY2FsbGJhY2tVcmwgfSk7XG4gICAgY29uc3QgcmVxID0gbmV3IFJlcXVlc3QodXJsLCB7IG1ldGhvZDogXCJQT1NUXCIsIGhlYWRlcnMsIGJvZHkgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgQXV0aChyZXEsIHsgLi4uY29uZmlnLCByYXcsIHNraXBDU1JGQ2hlY2sgfSk7XG4gICAgY29uc3QgY29va2llSmFyID0gYXdhaXQgY29va2llcygpO1xuICAgIGZvciAoY29uc3QgYyBvZiByZXM/LmNvb2tpZXMgPz8gW10pXG4gICAgICAgIGNvb2tpZUphci5zZXQoYy5uYW1lLCBjLnZhbHVlLCBjLm9wdGlvbnMpO1xuICAgIGNvbnN0IHJlc3BvbnNlVXJsID0gcmVzIGluc3RhbmNlb2YgUmVzcG9uc2UgPyByZXMuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKSA6IHJlcy5yZWRpcmVjdDtcbiAgICAvLyBOT1RFOiBpZiBmb3Igc29tZSB1bmV4cGVjdGVkIHJlYXNvbiB0aGUgcmVzcG9uc2VVcmwgaXMgbm90IHNldCxcbiAgICAvLyB3ZSByZWRpcmVjdCB0byB0aGUgb3JpZ2luYWwgdXJsXG4gICAgY29uc3QgcmVkaXJlY3RVcmwgPSByZXNwb25zZVVybCA/PyB1cmw7XG4gICAgaWYgKHNob3VsZFJlZGlyZWN0KVxuICAgICAgICByZXR1cm4gcmVkaXJlY3QocmVkaXJlY3RVcmwpO1xuICAgIHJldHVybiByZWRpcmVjdFVybDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduT3V0KG9wdGlvbnMsIGNvbmZpZykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhhd2FpdCBuZXh0SGVhZGVycygpKTtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKTtcbiAgICBjb25zdCB1cmwgPSBjcmVhdGVBY3Rpb25VUkwoXCJzaWdub3V0XCIsIFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYHgtZm9yd2FyZGVkLXByb3RvYCBpcyBub3QgbnVsbGFibGUsIG5leHQuanMgc2V0cyBpdCBieSBkZWZhdWx0XG4gICAgaGVhZGVycy5nZXQoXCJ4LWZvcndhcmRlZC1wcm90b1wiKSwgaGVhZGVycywgcHJvY2Vzcy5lbnYsIGNvbmZpZyk7XG4gICAgY29uc3QgY2FsbGJhY2tVcmwgPSBvcHRpb25zPy5yZWRpcmVjdFRvID8/IGhlYWRlcnMuZ2V0KFwiUmVmZXJlclwiKSA/PyBcIi9cIjtcbiAgICBjb25zdCBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGNhbGxiYWNrVXJsIH0pO1xuICAgIGNvbnN0IHJlcSA9IG5ldyBSZXF1ZXN0KHVybCwgeyBtZXRob2Q6IFwiUE9TVFwiLCBoZWFkZXJzLCBib2R5IH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IEF1dGgocmVxLCB7IC4uLmNvbmZpZywgcmF3LCBza2lwQ1NSRkNoZWNrIH0pO1xuICAgIGNvbnN0IGNvb2tpZUphciA9IGF3YWl0IGNvb2tpZXMoKTtcbiAgICBmb3IgKGNvbnN0IGMgb2YgcmVzPy5jb29raWVzID8/IFtdKVxuICAgICAgICBjb29raWVKYXIuc2V0KGMubmFtZSwgYy52YWx1ZSwgYy5vcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucz8ucmVkaXJlY3QgPz8gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIHJlZGlyZWN0KHJlcy5yZWRpcmVjdCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGUoZGF0YSwgY29uZmlnKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGF3YWl0IG5leHRIZWFkZXJzKCkpO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICBjb25zdCB1cmwgPSBjcmVhdGVBY3Rpb25VUkwoXCJzZXNzaW9uXCIsIFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYHgtZm9yd2FyZGVkLXByb3RvYCBpcyBub3QgbnVsbGFibGUsIG5leHQuanMgc2V0cyBpdCBieSBkZWZhdWx0XG4gICAgaGVhZGVycy5nZXQoXCJ4LWZvcndhcmRlZC1wcm90b1wiKSwgaGVhZGVycywgcHJvY2Vzcy5lbnYsIGNvbmZpZyk7XG4gICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHsgZGF0YSB9KTtcbiAgICBjb25zdCByZXEgPSBuZXcgUmVxdWVzdCh1cmwsIHsgbWV0aG9kOiBcIlBPU1RcIiwgaGVhZGVycywgYm9keSB9KTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBBdXRoKHJlcSwgeyAuLi5jb25maWcsIHJhdywgc2tpcENTUkZDaGVjayB9KTtcbiAgICBjb25zdCBjb29raWVKYXIgPSBhd2FpdCBjb29raWVzKCk7XG4gICAgZm9yIChjb25zdCBjIG9mIHJlcz8uY29va2llcyA/PyBbXSlcbiAgICAgICAgY29va2llSmFyLnNldChjLm5hbWUsIGMudmFsdWUsIGMub3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlcy5ib2R5O1xufVxuIl0sIm5hbWVzIjpbIkF1dGgiLCJyYXciLCJza2lwQ1NSRkNoZWNrIiwiY3JlYXRlQWN0aW9uVVJMIiwiaGVhZGVycyIsIm5leHRIZWFkZXJzIiwiY29va2llcyIsInJlZGlyZWN0Iiwic2lnbkluIiwicHJvdmlkZXIiLCJvcHRpb25zIiwiYXV0aG9yaXphdGlvblBhcmFtcyIsImNvbmZpZyIsIkhlYWRlcnMiLCJzaG91bGRSZWRpcmVjdCIsInJlZGlyZWN0VG8iLCJyZXN0IiwiRm9ybURhdGEiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImNhbGxiYWNrVXJsIiwidG9TdHJpbmciLCJnZXQiLCJzaWduSW5VUkwiLCJwcm9jZXNzIiwiZW52Iiwic2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwidXJsIiwiVVJMU2VhcmNoUGFyYW1zIiwiZm91bmRQcm92aWRlciIsInByb3ZpZGVyQ29uZmlnIiwicHJvdmlkZXJzIiwiZGVmYXVsdHMiLCJpZCIsInR5cGUiLCJyZXBsYWNlIiwic2V0IiwiYm9keSIsInJlcSIsIlJlcXVlc3QiLCJtZXRob2QiLCJyZXMiLCJjb29raWVKYXIiLCJjIiwibmFtZSIsInZhbHVlIiwicmVzcG9uc2VVcmwiLCJSZXNwb25zZSIsInJlZGlyZWN0VXJsIiwic2lnbk91dCIsInVwZGF0ZSIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/lib/actions.js\n");

/***/ }),

/***/ "./node_modules/next-auth/lib/client.js":
/*!**********************************************!*\
  !*** ./node_modules/next-auth/lib/client.js ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSessionError: () => (/* binding */ ClientSessionError),\n/* harmony export */   apiBaseUrl: () => (/* binding */ apiBaseUrl),\n/* harmony export */   fetchData: () => (/* binding */ fetchData),\n/* harmony export */   now: () => (/* binding */ now),\n/* harmony export */   parseUrl: () => (/* binding */ parseUrl),\n/* harmony export */   useOnline: () => (/* binding */ useOnline)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var _auth_core_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @auth/core/errors */ \"@auth/core/errors\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_auth_core_errors__WEBPACK_IMPORTED_MODULE_1__]);\n_auth_core_errors__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* __next_internal_client_entry_do_not_use__ ClientSessionError,fetchData,apiBaseUrl,useOnline,now,parseUrl auto */ \n\n/** @todo */ class ClientFetchError extends _auth_core_errors__WEBPACK_IMPORTED_MODULE_1__.AuthError {\n}\n/** @todo */ class ClientSessionError extends _auth_core_errors__WEBPACK_IMPORTED_MODULE_1__.AuthError {\n}\n// ------------------------ Internal ------------------------\n/**\n * If passed 'appContext' via getInitialProps() in _app.js\n * then get the req object from ctx and use that for the\n * req value to allow `fetchData` to\n * work seemlessly in getInitialProps() on server side\n * pages *and* in _app.js.\n * @internal\n */ async function fetchData(path, __NEXTAUTH, logger, req = {}) {\n    const url = `${apiBaseUrl(__NEXTAUTH)}/${path}`;\n    try {\n        const options = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...req?.headers?.cookie ? {\n                    cookie: req.headers.cookie\n                } : {}\n            }\n        };\n        if (req?.body) {\n            options.body = JSON.stringify(req.body);\n            options.method = \"POST\";\n        }\n        const res = await fetch(url, options);\n        const data = await res.json();\n        if (!res.ok) throw data;\n        return data;\n    } catch (error) {\n        logger.error(new ClientFetchError(error.message, error));\n        return null;\n    }\n}\n/** @internal */ function apiBaseUrl(__NEXTAUTH) {\n    if (true) {\n        // Return absolute path when called server side\n        return `${__NEXTAUTH.baseUrlServer}${__NEXTAUTH.basePathServer}`;\n    }\n    // Return relative path when called client side\n    return __NEXTAUTH.basePath;\n}\n/** @internal  */ function useOnline() {\n    const [isOnline, setIsOnline] = react__WEBPACK_IMPORTED_MODULE_0__.useState(typeof navigator !== \"undefined\" ? navigator.onLine : false);\n    const setOnline = ()=>setIsOnline(true);\n    const setOffline = ()=>setIsOnline(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"useOnline.useEffect\": ()=>{\n            window.addEventListener(\"online\", setOnline);\n            window.addEventListener(\"offline\", setOffline);\n            return ({\n                \"useOnline.useEffect\": ()=>{\n                    window.removeEventListener(\"online\", setOnline);\n                    window.removeEventListener(\"offline\", setOffline);\n                }\n            })[\"useOnline.useEffect\"];\n        }\n    }[\"useOnline.useEffect\"], []);\n    return isOnline;\n}\n/**\n * Returns the number of seconds elapsed since January 1, 1970 00:00:00 UTC.\n * @internal\n */ function now() {\n    return Math.floor(Date.now() / 1000);\n}\n/**\n * Returns an `URL` like object to make requests/redirects from server-side\n * @internal\n */ function parseUrl(url) {\n    const defaultUrl = new URL(\"http://localhost:3000/api/auth\");\n    if (url && !url.startsWith(\"http\")) {\n        url = `https://${url}`;\n    }\n    const _url = new URL(url || defaultUrl);\n    const path = (_url.pathname === \"/\" ? defaultUrl.pathname : _url.pathname)// Remove trailing slash\n    .replace(/\\/$/, \"\");\n    const base = `${_url.origin}${path}`;\n    return {\n        origin: _url.origin,\n        host: _url.host,\n        path,\n        base,\n        toString: ()=>base\n    };\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBOEM7UUFDQUcsVUFBVSxJQUFNSDtJQUNwQjtBQUNKIiwic291cmNlcyI6WyIvVXNlcnMvaG9odXk4NTIvRG9jdW1lbnRzL3o3Ni1hcHBzL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvbGliL2NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQXV0aEVycm9yIH0gZnJvbSBcIkBhdXRoL2NvcmUvZXJyb3JzXCI7XG4vKiogQHRvZG8gKi9cbmNsYXNzIENsaWVudEZldGNoRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xufVxuLyoqIEB0b2RvICovXG5leHBvcnQgY2xhc3MgQ2xpZW50U2Vzc2lvbkVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBJbnRlcm5hbCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogSWYgcGFzc2VkICdhcHBDb250ZXh0JyB2aWEgZ2V0SW5pdGlhbFByb3BzKCkgaW4gX2FwcC5qc1xuICogdGhlbiBnZXQgdGhlIHJlcSBvYmplY3QgZnJvbSBjdHggYW5kIHVzZSB0aGF0IGZvciB0aGVcbiAqIHJlcSB2YWx1ZSB0byBhbGxvdyBgZmV0Y2hEYXRhYCB0b1xuICogd29yayBzZWVtbGVzc2x5IGluIGdldEluaXRpYWxQcm9wcygpIG9uIHNlcnZlciBzaWRlXG4gKiBwYWdlcyAqYW5kKiBpbiBfYXBwLmpzLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEocGF0aCwgX19ORVhUQVVUSCwgbG9nZ2VyLCByZXEgPSB7fSkge1xuICAgIGNvbnN0IHVybCA9IGAke2FwaUJhc2VVcmwoX19ORVhUQVVUSCl9LyR7cGF0aH1gO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4uKHJlcT8uaGVhZGVycz8uY29va2llID8geyBjb29raWU6IHJlcS5oZWFkZXJzLmNvb2tpZSB9IDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlcT8uYm9keSkge1xuICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkocmVxLmJvZHkpO1xuICAgICAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBcIlBPU1RcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXMub2spXG4gICAgICAgICAgICB0aHJvdyBkYXRhO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihuZXcgQ2xpZW50RmV0Y2hFcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvcikpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXBpQmFzZVVybChfX05FWFRBVVRIKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gUmV0dXJuIGFic29sdXRlIHBhdGggd2hlbiBjYWxsZWQgc2VydmVyIHNpZGVcbiAgICAgICAgcmV0dXJuIGAke19fTkVYVEFVVEguYmFzZVVybFNlcnZlcn0ke19fTkVYVEFVVEguYmFzZVBhdGhTZXJ2ZXJ9YDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHJlbGF0aXZlIHBhdGggd2hlbiBjYWxsZWQgY2xpZW50IHNpZGVcbiAgICByZXR1cm4gX19ORVhUQVVUSC5iYXNlUGF0aDtcbn1cbi8qKiBAaW50ZXJuYWwgICovXG5leHBvcnQgZnVuY3Rpb24gdXNlT25saW5lKCkge1xuICAgIGNvbnN0IFtpc09ubGluZSwgc2V0SXNPbmxpbmVdID0gUmVhY3QudXNlU3RhdGUodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvci5vbkxpbmUgOiBmYWxzZSk7XG4gICAgY29uc3Qgc2V0T25saW5lID0gKCkgPT4gc2V0SXNPbmxpbmUodHJ1ZSk7XG4gICAgY29uc3Qgc2V0T2ZmbGluZSA9ICgpID0+IHNldElzT25saW5lKGZhbHNlKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBzZXRPbmxpbmUpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgc2V0T2ZmbGluZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBzZXRPbmxpbmUpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIHNldE9mZmxpbmUpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gaXNPbmxpbmU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBzZWNvbmRzIGVsYXBzZWQgc2luY2UgSmFudWFyeSAxLCAxOTcwIDAwOjAwOjAwIFVUQy5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBgVVJMYCBsaWtlIG9iamVjdCB0byBtYWtlIHJlcXVlc3RzL3JlZGlyZWN0cyBmcm9tIHNlcnZlci1zaWRlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xuICAgIGNvbnN0IGRlZmF1bHRVcmwgPSBuZXcgVVJMKFwiaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hdXRoXCIpO1xuICAgIGlmICh1cmwgJiYgIXVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgICAgICB1cmwgPSBgaHR0cHM6Ly8ke3VybH1gO1xuICAgIH1cbiAgICBjb25zdCBfdXJsID0gbmV3IFVSTCh1cmwgfHwgZGVmYXVsdFVybCk7XG4gICAgY29uc3QgcGF0aCA9IChfdXJsLnBhdGhuYW1lID09PSBcIi9cIiA/IGRlZmF1bHRVcmwucGF0aG5hbWUgOiBfdXJsLnBhdGhuYW1lKVxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgICAgICAgLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgICBjb25zdCBiYXNlID0gYCR7X3VybC5vcmlnaW59JHtwYXRofWA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luOiBfdXJsLm9yaWdpbixcbiAgICAgICAgaG9zdDogX3VybC5ob3N0LFxuICAgICAgICBwYXRoLFxuICAgICAgICBiYXNlLFxuICAgICAgICB0b1N0cmluZzogKCkgPT4gYmFzZSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiQXV0aEVycm9yIiwiQ2xpZW50RmV0Y2hFcnJvciIsIkNsaWVudFNlc3Npb25FcnJvciIsImZldGNoRGF0YSIsInBhdGgiLCJfX05FWFRBVVRIIiwibG9nZ2VyIiwicmVxIiwidXJsIiwiYXBpQmFzZVVybCIsIm9wdGlvbnMiLCJoZWFkZXJzIiwiY29va2llIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXRob2QiLCJyZXMiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwib2siLCJlcnJvciIsIm1lc3NhZ2UiLCJiYXNlVXJsU2VydmVyIiwiYmFzZVBhdGhTZXJ2ZXIiLCJiYXNlUGF0aCIsInVzZU9ubGluZSIsImlzT25saW5lIiwic2V0SXNPbmxpbmUiLCJ1c2VTdGF0ZSIsIm5hdmlnYXRvciIsIm9uTGluZSIsInNldE9ubGluZSIsInNldE9mZmxpbmUiLCJ1c2VFZmZlY3QiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm5vdyIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJwYXJzZVVybCIsImRlZmF1bHRVcmwiLCJVUkwiLCJzdGFydHNXaXRoIiwiX3VybCIsInBhdGhuYW1lIiwicmVwbGFjZSIsImJhc2UiLCJvcmlnaW4iLCJob3N0IiwidG9TdHJpbmciXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next-auth/lib/client.js\n");

/***/ }),

/***/ "./node_modules/next-auth/lib/env.js":
/*!*******************************************!*\
  !*** ./node_modules/next-auth/lib/env.js ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reqWithEnvURL: () => (/* binding */ reqWithEnvURL),\n/* harmony export */   setEnvDefaults: () => (/* binding */ setEnvDefaults)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"next/server\");\n/* harmony import */ var _auth_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @auth/core */ \"@auth/core\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_auth_core__WEBPACK_IMPORTED_MODULE_1__]);\n_auth_core__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// @ts-expect-error Next.js does not yet correctly use the `package.json#exports` field\n\n\n/** If `NEXTAUTH_URL` or `AUTH_URL` is defined, override the request's URL. */ function reqWithEnvURL(req) {\n    const url = process.env.AUTH_URL ?? process.env.NEXTAUTH_URL;\n    if (!url) return req;\n    const { origin: envOrigin } = new URL(url);\n    const { href, origin } = req.nextUrl;\n    return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextRequest(href.replace(origin, envOrigin), req);\n}\n/**\n * For backwards compatibility, `next-auth` checks for `NEXTAUTH_URL`\n * and the `basePath` by default is `/api/auth` instead of `/auth`\n * (which is the default for all other Auth.js integrations).\n *\n * For the same reason, `NEXTAUTH_SECRET` is also checked.\n */ function setEnvDefaults(config) {\n    try {\n        config.secret ?? (config.secret = process.env.AUTH_SECRET ?? process.env.NEXTAUTH_SECRET);\n        const url = process.env.AUTH_URL ?? process.env.NEXTAUTH_URL;\n        if (!url) return;\n        const { pathname } = new URL(url);\n        if (pathname === \"/\") return;\n        config.basePath || (config.basePath = pathname);\n    } catch  {\n    // Catching and swallowing potential URL parsing errors, we'll fall\n    // back to `/api/auth` below.\n    } finally{\n        config.basePath || (config.basePath = \"/api/auth\");\n        (0,_auth_core__WEBPACK_IMPORTED_MODULE_1__.setEnvDefaults)(process.env, config, true);\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2xpYi9lbnYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLHVGQUF1RjtBQUM3QztBQUN3QjtBQUNsRSw0RUFBNEUsR0FDckUsU0FBU0csY0FBY0MsR0FBRztJQUM3QixNQUFNQyxNQUFNQyxRQUFRQyxHQUFHLENBQUNDLFFBQVEsSUFBSUYsUUFBUUMsR0FBRyxDQUFDRSxZQUFZO0lBQzVELElBQUksQ0FBQ0osS0FDRCxPQUFPRDtJQUNYLE1BQU0sRUFBRU0sUUFBUUMsU0FBUyxFQUFFLEdBQUcsSUFBSUMsSUFBSVA7SUFDdEMsTUFBTSxFQUFFUSxJQUFJLEVBQUVILE1BQU0sRUFBRSxHQUFHTixJQUFJVSxPQUFPO0lBQ3BDLE9BQU8sSUFBSWQsb0RBQVdBLENBQUNhLEtBQUtFLE9BQU8sQ0FBQ0wsUUFBUUMsWUFBWVA7QUFDNUQ7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTSCxlQUFlZSxNQUFNO0lBQ2pDLElBQUk7UUFDQUEsT0FBT0MsTUFBTSxJQUFLRCxDQUFBQSxPQUFPQyxNQUFNLEdBQUdYLFFBQVFDLEdBQUcsQ0FBQ1csV0FBVyxJQUFJWixRQUFRQyxHQUFHLENBQUNZLGVBQWU7UUFDeEYsTUFBTWQsTUFBTUMsUUFBUUMsR0FBRyxDQUFDQyxRQUFRLElBQUlGLFFBQVFDLEdBQUcsQ0FBQ0UsWUFBWTtRQUM1RCxJQUFJLENBQUNKLEtBQ0Q7UUFDSixNQUFNLEVBQUVlLFFBQVEsRUFBRSxHQUFHLElBQUlSLElBQUlQO1FBQzdCLElBQUllLGFBQWEsS0FDYjtRQUNKSixPQUFPSyxRQUFRLElBQUtMLENBQUFBLE9BQU9LLFFBQVEsR0FBR0QsUUFBTztJQUNqRCxFQUNBLE9BQU07SUFDRixtRUFBbUU7SUFDbkUsNkJBQTZCO0lBQ2pDLFNBQ1E7UUFDSkosT0FBT0ssUUFBUSxJQUFLTCxDQUFBQSxPQUFPSyxRQUFRLEdBQUcsV0FBVTtRQUNoRG5CLDBEQUFrQkEsQ0FBQ0ksUUFBUUMsR0FBRyxFQUFFUyxRQUFRO0lBQzVDO0FBQ0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ob2h1eTg1Mi9Eb2N1bWVudHMvejc2LWFwcHMvbm9kZV9tb2R1bGVzL25leHQtYXV0aC9saWIvZW52LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1leHBlY3QtZXJyb3IgTmV4dC5qcyBkb2VzIG5vdCB5ZXQgY29ycmVjdGx5IHVzZSB0aGUgYHBhY2thZ2UuanNvbiNleHBvcnRzYCBmaWVsZFxuaW1wb3J0IHsgTmV4dFJlcXVlc3QgfSBmcm9tIFwibmV4dC9zZXJ2ZXJcIjtcbmltcG9ydCB7IHNldEVudkRlZmF1bHRzIGFzIGNvcmVTZXRFbnZEZWZhdWx0cyB9IGZyb20gXCJAYXV0aC9jb3JlXCI7XG4vKiogSWYgYE5FWFRBVVRIX1VSTGAgb3IgYEFVVEhfVVJMYCBpcyBkZWZpbmVkLCBvdmVycmlkZSB0aGUgcmVxdWVzdCdzIFVSTC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXFXaXRoRW52VVJMKHJlcSkge1xuICAgIGNvbnN0IHVybCA9IHByb2Nlc3MuZW52LkFVVEhfVVJMID8/IHByb2Nlc3MuZW52Lk5FWFRBVVRIX1VSTDtcbiAgICBpZiAoIXVybClcbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICBjb25zdCB7IG9yaWdpbjogZW52T3JpZ2luIH0gPSBuZXcgVVJMKHVybCk7XG4gICAgY29uc3QgeyBocmVmLCBvcmlnaW4gfSA9IHJlcS5uZXh0VXJsO1xuICAgIHJldHVybiBuZXcgTmV4dFJlcXVlc3QoaHJlZi5yZXBsYWNlKG9yaWdpbiwgZW52T3JpZ2luKSwgcmVxKTtcbn1cbi8qKlxuICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBgbmV4dC1hdXRoYCBjaGVja3MgZm9yIGBORVhUQVVUSF9VUkxgXG4gKiBhbmQgdGhlIGBiYXNlUGF0aGAgYnkgZGVmYXVsdCBpcyBgL2FwaS9hdXRoYCBpbnN0ZWFkIG9mIGAvYXV0aGBcbiAqICh3aGljaCBpcyB0aGUgZGVmYXVsdCBmb3IgYWxsIG90aGVyIEF1dGguanMgaW50ZWdyYXRpb25zKS5cbiAqXG4gKiBGb3IgdGhlIHNhbWUgcmVhc29uLCBgTkVYVEFVVEhfU0VDUkVUYCBpcyBhbHNvIGNoZWNrZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbnZEZWZhdWx0cyhjb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25maWcuc2VjcmV0ID8/IChjb25maWcuc2VjcmV0ID0gcHJvY2Vzcy5lbnYuQVVUSF9TRUNSRVQgPz8gcHJvY2Vzcy5lbnYuTkVYVEFVVEhfU0VDUkVUKTtcbiAgICAgICAgY29uc3QgdXJsID0gcHJvY2Vzcy5lbnYuQVVUSF9VUkwgPz8gcHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMO1xuICAgICAgICBpZiAoIXVybClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBwYXRobmFtZSB9ID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICBpZiAocGF0aG5hbWUgPT09IFwiL1wiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25maWcuYmFzZVBhdGggfHwgKGNvbmZpZy5iYXNlUGF0aCA9IHBhdGhuYW1lKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICAvLyBDYXRjaGluZyBhbmQgc3dhbGxvd2luZyBwb3RlbnRpYWwgVVJMIHBhcnNpbmcgZXJyb3JzLCB3ZSdsbCBmYWxsXG4gICAgICAgIC8vIGJhY2sgdG8gYC9hcGkvYXV0aGAgYmVsb3cuXG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjb25maWcuYmFzZVBhdGggfHwgKGNvbmZpZy5iYXNlUGF0aCA9IFwiL2FwaS9hdXRoXCIpO1xuICAgICAgICBjb3JlU2V0RW52RGVmYXVsdHMocHJvY2Vzcy5lbnYsIGNvbmZpZywgdHJ1ZSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIk5leHRSZXF1ZXN0Iiwic2V0RW52RGVmYXVsdHMiLCJjb3JlU2V0RW52RGVmYXVsdHMiLCJyZXFXaXRoRW52VVJMIiwicmVxIiwidXJsIiwicHJvY2VzcyIsImVudiIsIkFVVEhfVVJMIiwiTkVYVEFVVEhfVVJMIiwib3JpZ2luIiwiZW52T3JpZ2luIiwiVVJMIiwiaHJlZiIsIm5leHRVcmwiLCJyZXBsYWNlIiwiY29uZmlnIiwic2VjcmV0IiwiQVVUSF9TRUNSRVQiLCJORVhUQVVUSF9TRUNSRVQiLCJwYXRobmFtZSIsImJhc2VQYXRoIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/lib/env.js\n");

/***/ }),

/***/ "./node_modules/next-auth/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/next-auth/lib/index.js ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initAuth: () => (/* binding */ initAuth)\n/* harmony export */ });\n/* harmony import */ var _auth_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @auth/core */ \"@auth/core\");\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/headers */ \"./node_modules/next/headers.js\");\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/server */ \"next/server\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./env.js */ \"./node_modules/next-auth/lib/env.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_auth_core__WEBPACK_IMPORTED_MODULE_0__, _env_js__WEBPACK_IMPORTED_MODULE_3__]);\n([_auth_core__WEBPACK_IMPORTED_MODULE_0__, _env_js__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n// @ts-expect-error Next.js does not yet correctly use the `package.json#exports` field\n\n// @ts-expect-error Next.js does not yet correctly use the `package.json#exports` field\n\n\nasync function getSession(headers, config) {\n    const url = (0,_auth_core__WEBPACK_IMPORTED_MODULE_0__.createActionURL)(\"session\", // @ts-expect-error `x-forwarded-proto` is not nullable, next.js sets it by default\n    headers.get(\"x-forwarded-proto\"), headers, process.env, config);\n    const request = new Request(url, {\n        headers: {\n            cookie: headers.get(\"cookie\") ?? \"\"\n        }\n    });\n    return (0,_auth_core__WEBPACK_IMPORTED_MODULE_0__.Auth)(request, {\n        ...config,\n        callbacks: {\n            ...config.callbacks,\n            // Since we are server-side, we don't need to filter out the session data\n            // See https://authjs.dev/getting-started/migrating-to-v5#authenticating-server-side\n            // TODO: Taint the session data to prevent accidental leakage to the client\n            // https://react.dev/reference/react/experimental_taintObjectReference\n            async session (...args) {\n                const session = // If the user defined a custom session callback, use that instead\n                await config.callbacks?.session?.(...args) ?? {\n                    ...args[0].session,\n                    expires: args[0].session.expires?.toISOString?.() ?? args[0].session.expires\n                };\n                const user = args[0].user ?? args[0].token;\n                return {\n                    user,\n                    ...session\n                };\n            }\n        }\n    });\n}\nfunction isReqWrapper(arg) {\n    return typeof arg === \"function\";\n}\nfunction initAuth(config, onLazyLoad // To set the default env vars\n) {\n    if (typeof config === \"function\") {\n        return async (...args)=>{\n            if (!args.length) {\n                // React Server Components\n                const _headers = await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.headers)();\n                const _config = await config(undefined); // Review: Should we pass headers() here instead?\n                onLazyLoad?.(_config);\n                return getSession(_headers, _config).then((r)=>r.json());\n            }\n            if (args[0] instanceof Request) {\n                // middleware.ts inline\n                // export { auth as default } from \"auth\"\n                const req = args[0];\n                const ev = args[1];\n                const _config = await config(req);\n                onLazyLoad?.(_config);\n                // args[0] is supposed to be NextRequest but the instanceof check is failing.\n                return handleAuth([\n                    req,\n                    ev\n                ], _config);\n            }\n            if (isReqWrapper(args[0])) {\n                // middleware.ts wrapper/route.ts\n                // import { auth } from \"auth\"\n                // export default auth((req) => { console.log(req.auth) }})\n                const userMiddlewareOrRoute = args[0];\n                return async (...args)=>{\n                    const _config = await config(args[0]);\n                    onLazyLoad?.(_config);\n                    return handleAuth(args, _config, userMiddlewareOrRoute);\n                };\n            }\n            // API Routes, getServerSideProps\n            const request = \"req\" in args[0] ? args[0].req : args[0];\n            const response = \"res\" in args[0] ? args[0].res : args[1];\n            const _config = await config(request);\n            onLazyLoad?.(_config);\n            // @ts-expect-error -- request is NextRequest\n            return getSession(new Headers(request.headers), _config).then(async (authResponse)=>{\n                const auth = await authResponse.json();\n                for (const cookie of authResponse.headers.getSetCookie())if (\"headers\" in response) response.headers.append(\"set-cookie\", cookie);\n                else response.appendHeader(\"set-cookie\", cookie);\n                return auth;\n            });\n        };\n    }\n    return (...args)=>{\n        if (!args.length) {\n            // React Server Components\n            return Promise.resolve((0,next_headers__WEBPACK_IMPORTED_MODULE_1__.headers)()).then((h)=>getSession(h, config).then((r)=>r.json()));\n        }\n        if (args[0] instanceof Request) {\n            // middleware.ts inline\n            // export { auth as default } from \"auth\"\n            const req = args[0];\n            const ev = args[1];\n            return handleAuth([\n                req,\n                ev\n            ], config);\n        }\n        if (isReqWrapper(args[0])) {\n            // middleware.ts wrapper/route.ts\n            // import { auth } from \"auth\"\n            // export default auth((req) => { console.log(req.auth) }})\n            const userMiddlewareOrRoute = args[0];\n            return async (...args)=>{\n                return handleAuth(args, config, userMiddlewareOrRoute).then((res)=>{\n                    return res;\n                });\n            };\n        }\n        // API Routes, getServerSideProps\n        const request = \"req\" in args[0] ? args[0].req : args[0];\n        const response = \"res\" in args[0] ? args[0].res : args[1];\n        return getSession(// @ts-expect-error\n        new Headers(request.headers), config).then(async (authResponse)=>{\n            const auth = await authResponse.json();\n            for (const cookie of authResponse.headers.getSetCookie())if (\"headers\" in response) response.headers.append(\"set-cookie\", cookie);\n            else response.appendHeader(\"set-cookie\", cookie);\n            return auth;\n        });\n    };\n}\nasync function handleAuth(args, config, userMiddlewareOrRoute) {\n    const request = (0,_env_js__WEBPACK_IMPORTED_MODULE_3__.reqWithEnvURL)(args[0]);\n    const sessionResponse = await getSession(request.headers, config);\n    const auth = await sessionResponse.json();\n    let authorized = true;\n    if (config.callbacks?.authorized) {\n        authorized = await config.callbacks.authorized({\n            request,\n            auth\n        });\n    }\n    let response = next_server__WEBPACK_IMPORTED_MODULE_2__.NextResponse.next?.();\n    if (authorized instanceof Response) {\n        // User returned a custom response, like redirecting to a page or 401, respect it\n        response = authorized;\n        const redirect = authorized.headers.get(\"Location\");\n        const { pathname } = request.nextUrl;\n        // If the user is redirecting to the same NextAuth.js action path as the current request,\n        // don't allow the redirect to prevent an infinite loop\n        if (redirect && isSameAuthAction(pathname, new URL(redirect).pathname, config)) {\n            authorized = true;\n        }\n    } else if (userMiddlewareOrRoute) {\n        // Execute user's middleware/handler with the augmented request\n        const augmentedReq = request;\n        augmentedReq.auth = auth;\n        response = await userMiddlewareOrRoute(augmentedReq, args[1]) ?? next_server__WEBPACK_IMPORTED_MODULE_2__.NextResponse.next();\n    } else if (!authorized) {\n        const signInPage = config.pages?.signIn ?? `${config.basePath}/signin`;\n        if (request.nextUrl.pathname !== signInPage) {\n            // Redirect to signin page by default if not authorized\n            const signInUrl = request.nextUrl.clone();\n            signInUrl.pathname = signInPage;\n            signInUrl.searchParams.set(\"callbackUrl\", request.nextUrl.href);\n            response = next_server__WEBPACK_IMPORTED_MODULE_2__.NextResponse.redirect(signInUrl);\n        }\n    }\n    const finalResponse = new Response(response?.body, response);\n    // Preserve cookies from the session response\n    for (const cookie of sessionResponse.headers.getSetCookie())finalResponse.headers.append(\"set-cookie\", cookie);\n    return finalResponse;\n}\nfunction isSameAuthAction(requestPath, redirectPath, config) {\n    const action = redirectPath.replace(`${requestPath}/`, \"\");\n    const pages = Object.values(config.pages ?? {});\n    return (actions.has(action) || pages.includes(redirectPath)) && redirectPath === requestPath;\n}\nconst actions = new Set([\n    \"providers\",\n    \"session\",\n    \"csrf\",\n    \"signin\",\n    \"signout\",\n    \"callback\",\n    \"verify-request\",\n    \"error\"\n]);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TXZCLFVBQVVrQyxnQkFBZ0I3QyxPQUFPLENBQUN1QyxZQUFZLEdBQ3JEeUIsY0FBY2hFLE9BQU8sQ0FBQ3dDLE1BQU0sQ0FBQyxjQUFjN0I7SUFDL0MsT0FBT3FEO0FBQ1g7QUFDQSxTQUFTWixpQkFBaUJjLFdBQVcsRUFBRUMsWUFBWSxFQUFFL0QsTUFBTTtJQUN2RCxNQUFNZ0UsU0FBU0QsYUFBYUUsT0FBTyxDQUFDLEdBQUdILFlBQVksQ0FBQyxDQUFDLEVBQUU7SUFDdkQsTUFBTVYsUUFBUWMsT0FBT0MsTUFBTSxDQUFDbkUsT0FBT29ELEtBQUssSUFBSSxDQUFDO0lBQzdDLE9BQVEsQ0FBQ2dCLFFBQVFDLEdBQUcsQ0FBQ0wsV0FBV1osTUFBTWtCLFFBQVEsQ0FBQ1AsYUFBWSxLQUN2REEsaUJBQWlCRDtBQUN6QjtBQUNBLE1BQU1NLFVBQVUsSUFBSUcsSUFBSTtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0giLCJzb3VyY2VzIjpbIi9Vc2Vycy9ob2h1eTg1Mi9Eb2N1bWVudHMvejc2LWFwcHMvbm9kZV9tb2R1bGVzL25leHQtYXV0aC9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXV0aCwgY3JlYXRlQWN0aW9uVVJMIH0gZnJvbSBcIkBhdXRoL2NvcmVcIjtcbi8vIEB0cy1leHBlY3QtZXJyb3IgTmV4dC5qcyBkb2VzIG5vdCB5ZXQgY29ycmVjdGx5IHVzZSB0aGUgYHBhY2thZ2UuanNvbiNleHBvcnRzYCBmaWVsZFxuaW1wb3J0IHsgaGVhZGVycyB9IGZyb20gXCJuZXh0L2hlYWRlcnNcIjtcbi8vIEB0cy1leHBlY3QtZXJyb3IgTmV4dC5qcyBkb2VzIG5vdCB5ZXQgY29ycmVjdGx5IHVzZSB0aGUgYHBhY2thZ2UuanNvbiNleHBvcnRzYCBmaWVsZFxuaW1wb3J0IHsgTmV4dFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvc2VydmVyXCI7XG5pbXBvcnQgeyByZXFXaXRoRW52VVJMIH0gZnJvbSBcIi4vZW52LmpzXCI7XG5hc3luYyBmdW5jdGlvbiBnZXRTZXNzaW9uKGhlYWRlcnMsIGNvbmZpZykge1xuICAgIGNvbnN0IHVybCA9IGNyZWF0ZUFjdGlvblVSTChcInNlc3Npb25cIiwgXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgeC1mb3J3YXJkZWQtcHJvdG9gIGlzIG5vdCBudWxsYWJsZSwgbmV4dC5qcyBzZXRzIGl0IGJ5IGRlZmF1bHRcbiAgICBoZWFkZXJzLmdldChcIngtZm9yd2FyZGVkLXByb3RvXCIpLCBoZWFkZXJzLCBwcm9jZXNzLmVudiwgY29uZmlnKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCB7XG4gICAgICAgIGhlYWRlcnM6IHsgY29va2llOiBoZWFkZXJzLmdldChcImNvb2tpZVwiKSA/PyBcIlwiIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIEF1dGgocmVxdWVzdCwge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgLi4uY29uZmlnLmNhbGxiYWNrcyxcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGFyZSBzZXJ2ZXItc2lkZSwgd2UgZG9uJ3QgbmVlZCB0byBmaWx0ZXIgb3V0IHRoZSBzZXNzaW9uIGRhdGFcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2F1dGhqcy5kZXYvZ2V0dGluZy1zdGFydGVkL21pZ3JhdGluZy10by12NSNhdXRoZW50aWNhdGluZy1zZXJ2ZXItc2lkZVxuICAgICAgICAgICAgLy8gVE9ETzogVGFpbnQgdGhlIHNlc3Npb24gZGF0YSB0byBwcmV2ZW50IGFjY2lkZW50YWwgbGVha2FnZSB0byB0aGUgY2xpZW50XG4gICAgICAgICAgICAvLyBodHRwczovL3JlYWN0LmRldi9yZWZlcmVuY2UvcmVhY3QvZXhwZXJpbWVudGFsX3RhaW50T2JqZWN0UmVmZXJlbmNlXG4gICAgICAgICAgICBhc3luYyBzZXNzaW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgZGVmaW5lZCBhIGN1c3RvbSBzZXNzaW9uIGNhbGxiYWNrLCB1c2UgdGhhdCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgKGF3YWl0IGNvbmZpZy5jYWxsYmFja3M/LnNlc3Npb24/LiguLi5hcmdzKSkgPz8ge1xuICAgICAgICAgICAgICAgICAgICAuLi5hcmdzWzBdLnNlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXM6IGFyZ3NbMF0uc2Vzc2lvbi5leHBpcmVzPy50b0lTT1N0cmluZz8uKCkgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0uc2Vzc2lvbi5leHBpcmVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlciA9IGFyZ3NbMF0udXNlciA/PyBhcmdzWzBdLnRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVzZXIsIC4uLnNlc3Npb24gfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc1JlcVdyYXBwZXIoYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbml0QXV0aChjb25maWcsIG9uTGF6eUxvYWQgLy8gVG8gc2V0IHRoZSBkZWZhdWx0IGVudiB2YXJzXG4pIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFJlYWN0IFNlcnZlciBDb21wb25lbnRzXG4gICAgICAgICAgICAgICAgY29uc3QgX2hlYWRlcnMgPSBhd2FpdCBoZWFkZXJzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgX2NvbmZpZyA9IGF3YWl0IGNvbmZpZyh1bmRlZmluZWQpOyAvLyBSZXZpZXc6IFNob3VsZCB3ZSBwYXNzIGhlYWRlcnMoKSBoZXJlIGluc3RlYWQ/XG4gICAgICAgICAgICAgICAgb25MYXp5TG9hZD8uKF9jb25maWcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTZXNzaW9uKF9oZWFkZXJzLCBfY29uZmlnKS50aGVuKChyKSA9PiByLmpzb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBtaWRkbGV3YXJlLnRzIGlubGluZVxuICAgICAgICAgICAgICAgIC8vIGV4cG9ydCB7IGF1dGggYXMgZGVmYXVsdCB9IGZyb20gXCJhdXRoXCJcbiAgICAgICAgICAgICAgICBjb25zdCByZXEgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ID0gYXJnc1sxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBfY29uZmlnID0gYXdhaXQgY29uZmlnKHJlcSk7XG4gICAgICAgICAgICAgICAgb25MYXp5TG9hZD8uKF9jb25maWcpO1xuICAgICAgICAgICAgICAgIC8vIGFyZ3NbMF0gaXMgc3VwcG9zZWQgdG8gYmUgTmV4dFJlcXVlc3QgYnV0IHRoZSBpbnN0YW5jZW9mIGNoZWNrIGlzIGZhaWxpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUF1dGgoW3JlcSwgZXZdLCBfY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1JlcVdyYXBwZXIoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtaWRkbGV3YXJlLnRzIHdyYXBwZXIvcm91dGUudHNcbiAgICAgICAgICAgICAgICAvLyBpbXBvcnQgeyBhdXRoIH0gZnJvbSBcImF1dGhcIlxuICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IGF1dGgoKHJlcSkgPT4geyBjb25zb2xlLmxvZyhyZXEuYXV0aCkgfX0pXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlck1pZGRsZXdhcmVPclJvdXRlID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX2NvbmZpZyA9IGF3YWl0IGNvbmZpZyhhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgb25MYXp5TG9hZD8uKF9jb25maWcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlQXV0aChhcmdzLCBfY29uZmlnLCB1c2VyTWlkZGxld2FyZU9yUm91dGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUEkgUm91dGVzLCBnZXRTZXJ2ZXJTaWRlUHJvcHNcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBcInJlcVwiIGluIGFyZ3NbMF0gPyBhcmdzWzBdLnJlcSA6IGFyZ3NbMF07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IFwicmVzXCIgaW4gYXJnc1swXSA/IGFyZ3NbMF0ucmVzIDogYXJnc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IF9jb25maWcgPSBhd2FpdCBjb25maWcocmVxdWVzdCk7XG4gICAgICAgICAgICBvbkxhenlMb2FkPy4oX2NvbmZpZyk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIHJlcXVlc3QgaXMgTmV4dFJlcXVlc3RcbiAgICAgICAgICAgIHJldHVybiBnZXRTZXNzaW9uKG5ldyBIZWFkZXJzKHJlcXVlc3QuaGVhZGVycyksIF9jb25maWcpLnRoZW4oYXN5bmMgKGF1dGhSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGggPSBhd2FpdCBhdXRoUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29va2llIG9mIGF1dGhSZXNwb25zZS5oZWFkZXJzLmdldFNldENvb2tpZSgpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJoZWFkZXJzXCIgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLmFwcGVuZChcInNldC1jb29raWVcIiwgY29va2llKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYXBwZW5kSGVhZGVyKFwic2V0LWNvb2tpZVwiLCBjb29raWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhdXRoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50c1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShoZWFkZXJzKCkpLnRoZW4oKGgpID0+IGdldFNlc3Npb24oaCwgY29uZmlnKS50aGVuKChyKSA9PiByLmpzb24oKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAgICAgLy8gbWlkZGxld2FyZS50cyBpbmxpbmVcbiAgICAgICAgICAgIC8vIGV4cG9ydCB7IGF1dGggYXMgZGVmYXVsdCB9IGZyb20gXCJhdXRoXCJcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGFyZ3NbMF07XG4gICAgICAgICAgICBjb25zdCBldiA9IGFyZ3NbMV07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXV0aChbcmVxLCBldl0sIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmVxV3JhcHBlcihhcmdzWzBdKSkge1xuICAgICAgICAgICAgLy8gbWlkZGxld2FyZS50cyB3cmFwcGVyL3JvdXRlLnRzXG4gICAgICAgICAgICAvLyBpbXBvcnQgeyBhdXRoIH0gZnJvbSBcImF1dGhcIlxuICAgICAgICAgICAgLy8gZXhwb3J0IGRlZmF1bHQgYXV0aCgocmVxKSA9PiB7IGNvbnNvbGUubG9nKHJlcS5hdXRoKSB9fSlcbiAgICAgICAgICAgIGNvbnN0IHVzZXJNaWRkbGV3YXJlT3JSb3V0ZSA9IGFyZ3NbMF07XG4gICAgICAgICAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlQXV0aChhcmdzLCBjb25maWcsIHVzZXJNaWRkbGV3YXJlT3JSb3V0ZSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEFQSSBSb3V0ZXMsIGdldFNlcnZlclNpZGVQcm9wc1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gXCJyZXFcIiBpbiBhcmdzWzBdID8gYXJnc1swXS5yZXEgOiBhcmdzWzBdO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IFwicmVzXCIgaW4gYXJnc1swXSA/IGFyZ3NbMF0ucmVzIDogYXJnc1sxXTtcbiAgICAgICAgcmV0dXJuIGdldFNlc3Npb24oXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbmV3IEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKSwgY29uZmlnKS50aGVuKGFzeW5jIChhdXRoUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF1dGggPSBhd2FpdCBhdXRoUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb29raWUgb2YgYXV0aFJlc3BvbnNlLmhlYWRlcnMuZ2V0U2V0Q29va2llKCkpXG4gICAgICAgICAgICAgICAgaWYgKFwiaGVhZGVyc1wiIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLmFwcGVuZChcInNldC1jb29raWVcIiwgY29va2llKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmFwcGVuZEhlYWRlcihcInNldC1jb29raWVcIiwgY29va2llKTtcbiAgICAgICAgICAgIHJldHVybiBhdXRoO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlQXV0aChhcmdzLCBjb25maWcsIHVzZXJNaWRkbGV3YXJlT3JSb3V0ZSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSByZXFXaXRoRW52VVJMKGFyZ3NbMF0pO1xuICAgIGNvbnN0IHNlc3Npb25SZXNwb25zZSA9IGF3YWl0IGdldFNlc3Npb24ocmVxdWVzdC5oZWFkZXJzLCBjb25maWcpO1xuICAgIGNvbnN0IGF1dGggPSBhd2FpdCBzZXNzaW9uUmVzcG9uc2UuanNvbigpO1xuICAgIGxldCBhdXRob3JpemVkID0gdHJ1ZTtcbiAgICBpZiAoY29uZmlnLmNhbGxiYWNrcz8uYXV0aG9yaXplZCkge1xuICAgICAgICBhdXRob3JpemVkID0gYXdhaXQgY29uZmlnLmNhbGxiYWNrcy5hdXRob3JpemVkKHsgcmVxdWVzdCwgYXV0aCB9KTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlID0gTmV4dFJlc3BvbnNlLm5leHQ/LigpO1xuICAgIGlmIChhdXRob3JpemVkIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgLy8gVXNlciByZXR1cm5lZCBhIGN1c3RvbSByZXNwb25zZSwgbGlrZSByZWRpcmVjdGluZyB0byBhIHBhZ2Ugb3IgNDAxLCByZXNwZWN0IGl0XG4gICAgICAgIHJlc3BvbnNlID0gYXV0aG9yaXplZDtcbiAgICAgICAgY29uc3QgcmVkaXJlY3QgPSBhdXRob3JpemVkLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHJlcXVlc3QubmV4dFVybDtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaXMgcmVkaXJlY3RpbmcgdG8gdGhlIHNhbWUgTmV4dEF1dGguanMgYWN0aW9uIHBhdGggYXMgdGhlIGN1cnJlbnQgcmVxdWVzdCxcbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgdGhlIHJlZGlyZWN0IHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICBpZiAocmVkaXJlY3QgJiZcbiAgICAgICAgICAgIGlzU2FtZUF1dGhBY3Rpb24ocGF0aG5hbWUsIG5ldyBVUkwocmVkaXJlY3QpLnBhdGhuYW1lLCBjb25maWcpKSB7XG4gICAgICAgICAgICBhdXRob3JpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1c2VyTWlkZGxld2FyZU9yUm91dGUpIHtcbiAgICAgICAgLy8gRXhlY3V0ZSB1c2VyJ3MgbWlkZGxld2FyZS9oYW5kbGVyIHdpdGggdGhlIGF1Z21lbnRlZCByZXF1ZXN0XG4gICAgICAgIGNvbnN0IGF1Z21lbnRlZFJlcSA9IHJlcXVlc3Q7XG4gICAgICAgIGF1Z21lbnRlZFJlcS5hdXRoID0gYXV0aDtcbiAgICAgICAgcmVzcG9uc2UgPVxuICAgICAgICAgICAgKGF3YWl0IHVzZXJNaWRkbGV3YXJlT3JSb3V0ZShhdWdtZW50ZWRSZXEsIGFyZ3NbMV0pKSA/P1xuICAgICAgICAgICAgICAgIE5leHRSZXNwb25zZS5uZXh0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhdXRob3JpemVkKSB7XG4gICAgICAgIGNvbnN0IHNpZ25JblBhZ2UgPSBjb25maWcucGFnZXM/LnNpZ25JbiA/PyBgJHtjb25maWcuYmFzZVBhdGh9L3NpZ25pbmA7XG4gICAgICAgIGlmIChyZXF1ZXN0Lm5leHRVcmwucGF0aG5hbWUgIT09IHNpZ25JblBhZ2UpIHtcbiAgICAgICAgICAgIC8vIFJlZGlyZWN0IHRvIHNpZ25pbiBwYWdlIGJ5IGRlZmF1bHQgaWYgbm90IGF1dGhvcml6ZWRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25JblVybCA9IHJlcXVlc3QubmV4dFVybC5jbG9uZSgpO1xuICAgICAgICAgICAgc2lnbkluVXJsLnBhdGhuYW1lID0gc2lnbkluUGFnZTtcbiAgICAgICAgICAgIHNpZ25JblVybC5zZWFyY2hQYXJhbXMuc2V0KFwiY2FsbGJhY2tVcmxcIiwgcmVxdWVzdC5uZXh0VXJsLmhyZWYpO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBOZXh0UmVzcG9uc2UucmVkaXJlY3Qoc2lnbkluVXJsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaW5hbFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHJlc3BvbnNlPy5ib2R5LCByZXNwb25zZSk7XG4gICAgLy8gUHJlc2VydmUgY29va2llcyBmcm9tIHRoZSBzZXNzaW9uIHJlc3BvbnNlXG4gICAgZm9yIChjb25zdCBjb29raWUgb2Ygc2Vzc2lvblJlc3BvbnNlLmhlYWRlcnMuZ2V0U2V0Q29va2llKCkpXG4gICAgICAgIGZpbmFsUmVzcG9uc2UuaGVhZGVycy5hcHBlbmQoXCJzZXQtY29va2llXCIsIGNvb2tpZSk7XG4gICAgcmV0dXJuIGZpbmFsUmVzcG9uc2U7XG59XG5mdW5jdGlvbiBpc1NhbWVBdXRoQWN0aW9uKHJlcXVlc3RQYXRoLCByZWRpcmVjdFBhdGgsIGNvbmZpZykge1xuICAgIGNvbnN0IGFjdGlvbiA9IHJlZGlyZWN0UGF0aC5yZXBsYWNlKGAke3JlcXVlc3RQYXRofS9gLCBcIlwiKTtcbiAgICBjb25zdCBwYWdlcyA9IE9iamVjdC52YWx1ZXMoY29uZmlnLnBhZ2VzID8/IHt9KTtcbiAgICByZXR1cm4gKChhY3Rpb25zLmhhcyhhY3Rpb24pIHx8IHBhZ2VzLmluY2x1ZGVzKHJlZGlyZWN0UGF0aCkpICYmXG4gICAgICAgIHJlZGlyZWN0UGF0aCA9PT0gcmVxdWVzdFBhdGgpO1xufVxuY29uc3QgYWN0aW9ucyA9IG5ldyBTZXQoW1xuICAgIFwicHJvdmlkZXJzXCIsXG4gICAgXCJzZXNzaW9uXCIsXG4gICAgXCJjc3JmXCIsXG4gICAgXCJzaWduaW5cIixcbiAgICBcInNpZ25vdXRcIixcbiAgICBcImNhbGxiYWNrXCIsXG4gICAgXCJ2ZXJpZnktcmVxdWVzdFwiLFxuICAgIFwiZXJyb3JcIixcbl0pO1xuIl0sIm5hbWVzIjpbIkF1dGgiLCJjcmVhdGVBY3Rpb25VUkwiLCJoZWFkZXJzIiwiTmV4dFJlc3BvbnNlIiwicmVxV2l0aEVudlVSTCIsImdldFNlc3Npb24iLCJjb25maWciLCJ1cmwiLCJnZXQiLCJwcm9jZXNzIiwiZW52IiwicmVxdWVzdCIsIlJlcXVlc3QiLCJjb29raWUiLCJjYWxsYmFja3MiLCJzZXNzaW9uIiwiYXJncyIsImV4cGlyZXMiLCJ0b0lTT1N0cmluZyIsInVzZXIiLCJ0b2tlbiIsImlzUmVxV3JhcHBlciIsImFyZyIsImluaXRBdXRoIiwib25MYXp5TG9hZCIsImxlbmd0aCIsIl9oZWFkZXJzIiwiX2NvbmZpZyIsInVuZGVmaW5lZCIsInRoZW4iLCJyIiwianNvbiIsInJlcSIsImV2IiwiaGFuZGxlQXV0aCIsInVzZXJNaWRkbGV3YXJlT3JSb3V0ZSIsInJlc3BvbnNlIiwicmVzIiwiSGVhZGVycyIsImF1dGhSZXNwb25zZSIsImF1dGgiLCJnZXRTZXRDb29raWUiLCJhcHBlbmQiLCJhcHBlbmRIZWFkZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsImgiLCJzZXNzaW9uUmVzcG9uc2UiLCJhdXRob3JpemVkIiwibmV4dCIsIlJlc3BvbnNlIiwicmVkaXJlY3QiLCJwYXRobmFtZSIsIm5leHRVcmwiLCJpc1NhbWVBdXRoQWN0aW9uIiwiVVJMIiwiYXVnbWVudGVkUmVxIiwic2lnbkluUGFnZSIsInBhZ2VzIiwic2lnbkluIiwiYmFzZVBhdGgiLCJzaWduSW5VcmwiLCJjbG9uZSIsInNlYXJjaFBhcmFtcyIsInNldCIsImhyZWYiLCJmaW5hbFJlc3BvbnNlIiwiYm9keSIsInJlcXVlc3RQYXRoIiwicmVkaXJlY3RQYXRoIiwiYWN0aW9uIiwicmVwbGFjZSIsIk9iamVjdCIsInZhbHVlcyIsImFjdGlvbnMiLCJoYXMiLCJpbmNsdWRlcyIsIlNldCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/lib/index.js\n");

/***/ }),

/***/ "./node_modules/next-auth/providers/google.js":
/*!****************************************************!*\
  !*** ./node_modules/next-auth/providers/google.js ***!
  \****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport safe */ _auth_core_providers_google__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _auth_core_providers_google__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @auth/core/providers/google */ \"@auth/core/providers/google\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_auth_core_providers_google__WEBPACK_IMPORTED_MODULE_0__]);\n_auth_core_providers_google__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _auth_core_providers_google__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _auth_core_providers_google__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3Byb3ZpZGVycy9nb29nbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNEM7QUFDVSIsInNvdXJjZXMiOlsiL1VzZXJzL2hvaHV5ODUyL0RvY3VtZW50cy96NzYtYXBwcy9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL3Byb3ZpZGVycy9nb29nbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIkBhdXRoL2NvcmUvcHJvdmlkZXJzL2dvb2dsZVwiO1xuZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCJAYXV0aC9jb3JlL3Byb3ZpZGVycy9nb29nbGVcIjtcbiJdLCJuYW1lcyI6WyJkZWZhdWx0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-auth/providers/google.js\n");

/***/ }),

/***/ "./node_modules/next-auth/react.js":
/*!*****************************************!*\
  !*** ./node_modules/next-auth/react.js ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SessionContext: () => (/* binding */ SessionContext),\n/* harmony export */   SessionProvider: () => (/* binding */ SessionProvider),\n/* harmony export */   __NEXTAUTH: () => (/* binding */ __NEXTAUTH),\n/* harmony export */   getCsrfToken: () => (/* binding */ getCsrfToken),\n/* harmony export */   getProviders: () => (/* binding */ getProviders),\n/* harmony export */   getSession: () => (/* binding */ getSession),\n/* harmony export */   signIn: () => (/* binding */ signIn),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   useSession: () => (/* binding */ useSession)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var _lib_client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/client.js */ \"./node_modules/next-auth/lib/client.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_lib_client_js__WEBPACK_IMPORTED_MODULE_2__]);\n_lib_client_js__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/**\n *\n * NextAuth.js is the official integration of Auth.js for Next.js applications. It supports both\n * [Client Components](https://nextjs.org/docs/app/building-your-application/rendering/client-components) and the\n * [Pages Router](https://nextjs.org/docs/pages). It includes methods for signing in, signing out, hooks, and a React\n * Context provider to wrap your application and make session data available anywhere.\n *\n * For use in [Server Actions](https://nextjs.org/docs/app/api-reference/functions/server-actions), check out [these methods](https://authjs.dev/guides/upgrade-to-v5#methods)\n *\n * @module react\n */ /* __next_internal_client_entry_do_not_use__ __NEXTAUTH,SessionContext,useSession,getSession,getCsrfToken,getProviders,signIn,signOut,SessionProvider auto */ \n\n\n// This behaviour mirrors the default behaviour for getting the site name that\n// happens server side in server/index.js\n// 1. An empty value is legitimate when the code is being invoked client side as\n//    relative URLs are valid in that context and so defaults to empty.\n// 2. When invoked server side the value is picked up from an environment\n//    variable and defaults to 'http://localhost:3000'.\nconst __NEXTAUTH = {\n    baseUrl: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL ?? process.env.VERCEL_URL).origin,\n    basePath: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL).path,\n    baseUrlServer: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL_INTERNAL ?? process.env.NEXTAUTH_URL ?? process.env.VERCEL_URL).origin,\n    basePathServer: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL_INTERNAL ?? process.env.NEXTAUTH_URL).path,\n    _lastSync: 0,\n    _session: undefined,\n    _getSession: ()=>{}\n};\nlet broadcastChannel = null;\nfunction getNewBroadcastChannel() {\n    return new BroadcastChannel(\"next-auth\");\n}\nfunction broadcast() {\n    if (typeof BroadcastChannel === \"undefined\") {\n        return {\n            postMessage: ()=>{},\n            addEventListener: ()=>{},\n            removeEventListener: ()=>{}\n        };\n    }\n    if (broadcastChannel === null) {\n        broadcastChannel = getNewBroadcastChannel();\n    }\n    return broadcastChannel;\n}\n// TODO:\nconst logger = {\n    debug: console.debug,\n    error: console.error,\n    warn: console.warn\n};\nconst SessionContext = react__WEBPACK_IMPORTED_MODULE_1__.createContext?.(undefined);\n/**\n * React Hook that gives you access to the logged in user's session data and lets you modify it.\n *\n * :::info\n * `useSession` is for client-side use only and when using [Next.js App Router (`app/`)](https://nextjs.org/blog/next-13-4#nextjs-app-router) you should prefer the `auth()` export.\n * :::\n */ function useSession(options) {\n    if (!SessionContext) {\n        throw new Error(\"React Context is unavailable in Server Components\");\n    }\n    // @ts-expect-error Satisfy TS if branch on line below\n    const value = react__WEBPACK_IMPORTED_MODULE_1__.useContext(SessionContext);\n    if (!value && \"development\" !== \"production\") {\n        throw new Error(\"[next-auth]: `useSession` must be wrapped in a <SessionProvider />\");\n    }\n    const { required, onUnauthenticated } = options ?? {};\n    const requiredAndNotLoading = required && value.status === \"unauthenticated\";\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"useSession.useEffect\": ()=>{\n            if (requiredAndNotLoading) {\n                const url = `${__NEXTAUTH.basePath}/signin?${new URLSearchParams({\n                    error: \"SessionRequired\",\n                    callbackUrl: window.location.href\n                })}`;\n                if (onUnauthenticated) onUnauthenticated();\n                else window.location.href = url;\n            }\n        }\n    }[\"useSession.useEffect\"], [\n        requiredAndNotLoading,\n        onUnauthenticated\n    ]);\n    if (requiredAndNotLoading) {\n        return {\n            data: value.data,\n            update: value.update,\n            status: \"loading\"\n        };\n    }\n    return value;\n}\nasync function getSession(params) {\n    const session = await (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"session\", __NEXTAUTH, logger, params);\n    if (params?.broadcast ?? true) {\n        const broadcastChannel = getNewBroadcastChannel();\n        broadcastChannel.postMessage({\n            event: \"session\",\n            data: {\n                trigger: \"getSession\"\n            }\n        });\n    }\n    return session;\n}\n/**\n * Returns the current Cross-Site Request Forgery Token (CSRF Token)\n * required to make requests that changes state. (e.g. signing in or out, or updating the session).\n *\n * [CSRF Prevention: Double Submit Cookie](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie)\n */ async function getCsrfToken() {\n    const response = await (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"csrf\", __NEXTAUTH, logger);\n    return response?.csrfToken ?? \"\";\n}\n/**\n * Returns a client-safe configuration object of the currently\n * available providers.\n */ async function getProviders() {\n    return (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"providers\", __NEXTAUTH, logger);\n}\n/**\n * Initiate a signin flow or send the user to the signin page listing all possible providers.\n * Handles CSRF protection.\n */ async function signIn(provider, options, authorizationParams) {\n    const { redirect = true } = options ?? {};\n    const redirectTo = options?.redirectTo ?? options?.callbackUrl ?? window.location.href;\n    const baseUrl = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.apiBaseUrl)(__NEXTAUTH);\n    const providers = await getProviders();\n    if (!providers) {\n        window.location.href = `${baseUrl}/error`;\n        return;\n    }\n    if (!provider || !(provider in providers)) {\n        window.location.href = `${baseUrl}/signin?${new URLSearchParams({\n            callbackUrl: redirectTo\n        })}`;\n        return;\n    }\n    const isCredentials = providers[provider].type === \"credentials\";\n    const isEmail = providers[provider].type === \"email\";\n    const isSupportingReturn = isCredentials || isEmail;\n    const signInUrl = `${baseUrl}/${isCredentials ? \"callback\" : \"signin\"}/${provider}`;\n    const csrfToken = await getCsrfToken();\n    const res = await fetch(`${signInUrl}?${new URLSearchParams(authorizationParams)}`, {\n        method: \"post\",\n        headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"X-Auth-Return-Redirect\": \"1\"\n        },\n        // @ts-expect-error\n        body: new URLSearchParams({\n            ...options,\n            csrfToken,\n            callbackUrl: redirectTo\n        })\n    });\n    const data = await res.json();\n    // TODO: Do not redirect for Credentials and Email providers by default in next major\n    if (redirect || !isSupportingReturn) {\n        const url = data.url ?? redirectTo;\n        window.location.href = url;\n        // If url contains a hash, the browser does not reload the page. We reload manually\n        if (url.includes(\"#\")) window.location.reload();\n        return;\n    }\n    const error = new URL(data.url).searchParams.get(\"error\");\n    const code = new URL(data.url).searchParams.get(\"code\");\n    if (res.ok) {\n        await __NEXTAUTH._getSession({\n            event: \"storage\"\n        });\n    }\n    return {\n        error,\n        code,\n        status: res.status,\n        ok: res.ok,\n        url: error ? null : data.url\n    };\n}\n/**\n * Initiate a signout, by destroying the current session.\n * Handles CSRF protection.\n */ async function signOut(options) {\n    const redirectTo = options?.redirectTo ?? options?.callbackUrl ?? window.location.href;\n    const baseUrl = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.apiBaseUrl)(__NEXTAUTH);\n    const csrfToken = await getCsrfToken();\n    const res = await fetch(`${baseUrl}/signout`, {\n        method: \"post\",\n        headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"X-Auth-Return-Redirect\": \"1\"\n        },\n        body: new URLSearchParams({\n            csrfToken,\n            callbackUrl: redirectTo\n        })\n    });\n    const data = await res.json();\n    broadcast().postMessage({\n        event: \"session\",\n        data: {\n            trigger: \"signout\"\n        }\n    });\n    if (options?.redirect ?? true) {\n        const url = data.url ?? redirectTo;\n        window.location.href = url;\n        // If url contains a hash, the browser does not reload the page. We reload manually\n        if (url.includes(\"#\")) window.location.reload();\n        // @ts-expect-error\n        return;\n    }\n    await __NEXTAUTH._getSession({\n        event: \"storage\"\n    });\n    return data;\n}\n/**\n * [React Context](https://react.dev/learn/passing-data-deeply-with-context) provider to wrap the app (`pages/`) to make session data available anywhere.\n *\n * When used, the session state is automatically synchronized across all open tabs/windows and they are all updated whenever they gain or lose focus\n * or the state changes (e.g. a user signs in or out) when {@link SessionProviderProps.refetchOnWindowFocus} is `true`.\n *\n * :::info\n * `SessionProvider` is for client-side use only and when using [Next.js App Router (`app/`)](https://nextjs.org/blog/next-13-4#nextjs-app-router) you should prefer the `auth()` export.\n * :::\n */ function SessionProvider(props) {\n    if (!SessionContext) {\n        throw new Error(\"React Context is unavailable in Server Components\");\n    }\n    const { children, basePath, refetchInterval, refetchWhenOffline } = props;\n    if (basePath) __NEXTAUTH.basePath = basePath;\n    /**\n     * If session was `null`, there was an attempt to fetch it,\n     * but it failed, but we still treat it as a valid initial value.\n     */ const hasInitialSession = props.session !== undefined;\n    /** If session was passed, initialize as already synced */ __NEXTAUTH._lastSync = hasInitialSession ? (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)() : 0;\n    const [session, setSession] = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        \"SessionProvider.useState\": ()=>{\n            if (hasInitialSession) __NEXTAUTH._session = props.session;\n            return props.session;\n        }\n    }[\"SessionProvider.useState\"]);\n    /** If session was passed, initialize as not loading */ const [loading, setLoading] = react__WEBPACK_IMPORTED_MODULE_1__.useState(!hasInitialSession);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"SessionProvider.useEffect\": ()=>{\n            __NEXTAUTH._getSession = ({\n                \"SessionProvider.useEffect\": async ({ event } = {})=>{\n                    try {\n                        const storageEvent = event === \"storage\";\n                        // We should always update if we don't have a client session yet\n                        // or if there are events from other tabs/windows\n                        if (storageEvent || __NEXTAUTH._session === undefined) {\n                            __NEXTAUTH._lastSync = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)();\n                            __NEXTAUTH._session = await getSession({\n                                broadcast: !storageEvent\n                            });\n                            setSession(__NEXTAUTH._session);\n                            return;\n                        }\n                        if (// If there is no time defined for when a session should be considered\n                        // stale, then it's okay to use the value we have until an event is\n                        // triggered which updates it\n                        !event || // If the client doesn't have a session then we don't need to call\n                        // the server to check if it does (if they have signed in via another\n                        // tab or window that will come through as a \"stroage\" event\n                        // event anyway)\n                        __NEXTAUTH._session === null || // Bail out early if the client session is not stale yet\n                        (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)() < __NEXTAUTH._lastSync) {\n                            return;\n                        }\n                        // An event or session staleness occurred, update the client session.\n                        __NEXTAUTH._lastSync = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)();\n                        __NEXTAUTH._session = await getSession();\n                        setSession(__NEXTAUTH._session);\n                    } catch (error) {\n                        logger.error(new _lib_client_js__WEBPACK_IMPORTED_MODULE_2__.ClientSessionError(error.message, error));\n                    } finally{\n                        setLoading(false);\n                    }\n                }\n            })[\"SessionProvider.useEffect\"];\n            __NEXTAUTH._getSession();\n            return ({\n                \"SessionProvider.useEffect\": ()=>{\n                    __NEXTAUTH._lastSync = 0;\n                    __NEXTAUTH._session = undefined;\n                    __NEXTAUTH._getSession = ({\n                        \"SessionProvider.useEffect\": ()=>{}\n                    })[\"SessionProvider.useEffect\"];\n                }\n            })[\"SessionProvider.useEffect\"];\n        }\n    }[\"SessionProvider.useEffect\"], []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"SessionProvider.useEffect\": ()=>{\n            const handle = {\n                \"SessionProvider.useEffect.handle\": ()=>__NEXTAUTH._getSession({\n                        event: \"storage\"\n                    })\n            }[\"SessionProvider.useEffect.handle\"];\n            // Listen for storage events and update session if event fired from\n            // another window (but suppress firing another event to avoid a loop)\n            // Fetch new session data but tell it to not to fire another event to\n            // avoid an infinite loop.\n            // Note: We could pass session data through and do something like\n            // `setData(message.data)` but that can cause problems depending\n            // on how the session object is being used in the client; it is\n            // more robust to have each window/tab fetch it's own copy of the\n            // session object rather than share it across instances.\n            broadcast().addEventListener(\"message\", handle);\n            return ({\n                \"SessionProvider.useEffect\": ()=>broadcast().removeEventListener(\"message\", handle)\n            })[\"SessionProvider.useEffect\"];\n        }\n    }[\"SessionProvider.useEffect\"], []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"SessionProvider.useEffect\": ()=>{\n            const { refetchOnWindowFocus = true } = props;\n            // Listen for when the page is visible, if the user switches tabs\n            // and makes our tab visible again, re-fetch the session, but only if\n            // this feature is not disabled.\n            const visibilityHandler = {\n                \"SessionProvider.useEffect.visibilityHandler\": ()=>{\n                    if (refetchOnWindowFocus && document.visibilityState === \"visible\") __NEXTAUTH._getSession({\n                        event: \"visibilitychange\"\n                    });\n                }\n            }[\"SessionProvider.useEffect.visibilityHandler\"];\n            document.addEventListener(\"visibilitychange\", visibilityHandler, false);\n            return ({\n                \"SessionProvider.useEffect\": ()=>document.removeEventListener(\"visibilitychange\", visibilityHandler, false)\n            })[\"SessionProvider.useEffect\"];\n        }\n    }[\"SessionProvider.useEffect\"], [\n        props.refetchOnWindowFocus\n    ]);\n    const isOnline = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.useOnline)();\n    // TODO: Flip this behavior in next major version\n    const shouldRefetch = refetchWhenOffline !== false || isOnline;\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"SessionProvider.useEffect\": ()=>{\n            if (refetchInterval && shouldRefetch) {\n                const refetchIntervalTimer = setInterval({\n                    \"SessionProvider.useEffect.refetchIntervalTimer\": ()=>{\n                        if (__NEXTAUTH._session) {\n                            __NEXTAUTH._getSession({\n                                event: \"poll\"\n                            });\n                        }\n                    }\n                }[\"SessionProvider.useEffect.refetchIntervalTimer\"], refetchInterval * 1000);\n                return ({\n                    \"SessionProvider.useEffect\": ()=>clearInterval(refetchIntervalTimer)\n                })[\"SessionProvider.useEffect\"];\n            }\n        }\n    }[\"SessionProvider.useEffect\"], [\n        refetchInterval,\n        shouldRefetch\n    ]);\n    const value = react__WEBPACK_IMPORTED_MODULE_1__.useMemo({\n        \"SessionProvider.useMemo[value]\": ()=>({\n                data: session,\n                status: loading ? \"loading\" : session ? \"authenticated\" : \"unauthenticated\",\n                async update (data) {\n                    if (loading) return;\n                    setLoading(true);\n                    const newSession = await (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"session\", __NEXTAUTH, logger, typeof data === \"undefined\" ? undefined : {\n                        body: {\n                            csrfToken: await getCsrfToken(),\n                            data\n                        }\n                    });\n                    setLoading(false);\n                    if (newSession) {\n                        setSession(newSession);\n                        broadcast().postMessage({\n                            event: \"session\",\n                            data: {\n                                trigger: \"getSession\"\n                            }\n                        });\n                    }\n                    return newSession;\n                }\n            })\n    }[\"SessionProvider.useMemo[value]\"], [\n        session,\n        loading\n    ]);\n    return(// @ts-expect-error\n    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SessionContext.Provider, {\n        value: value,\n        children: children\n    }));\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMxQixpREFBaUQ7SUFDakQsTUFBTXFHLGdCQUFnQmQsdUJBQXVCLFNBQVNhO0lBQ3REMUcsNENBQWU7cUNBQUM7WUFDWixJQUFJNEYsbUJBQW1CZSxlQUFlO2dCQUNsQyxNQUFNQyx1QkFBdUJDO3NFQUFZO3dCQUNyQyxJQUFJdEcsV0FBV2EsUUFBUSxFQUFFOzRCQUNyQmIsV0FBV2UsV0FBVyxDQUFDO2dDQUFFb0MsT0FBTzs0QkFBTzt3QkFDM0M7b0JBQ0o7cUVBQUdrQyxrQkFBa0I7Z0JBQ3JCO2lEQUFPLElBQU1rQixjQUFjRjs7WUFDL0I7UUFDSjtvQ0FBRztRQUFDaEI7UUFBaUJlO0tBQWM7SUFDbkMsTUFBTW5FLFFBQVF4QywwQ0FBYTswQ0FBQyxJQUFPO2dCQUMvQnFELE1BQU1JO2dCQUNOWixRQUFRb0QsVUFDRixZQUNBeEMsVUFDSSxrQkFDQTtnQkFDVixNQUFNSCxRQUFPRCxJQUFJO29CQUNiLElBQUk0QyxTQUNBO29CQUNKQyxXQUFXO29CQUNYLE1BQU1jLGFBQWEsTUFBTTdHLHlEQUFTQSxDQUFDLFdBQVdJLFlBQVl1QixRQUFRLE9BQU91QixTQUFTLGNBQzVFaEMsWUFDQTt3QkFBRTBELE1BQU07NEJBQUVqQixXQUFXLE1BQU1GOzRCQUFnQlA7d0JBQUs7b0JBQUU7b0JBQ3hENkMsV0FBVztvQkFDWCxJQUFJYyxZQUFZO3dCQUNaakIsV0FBV2lCO3dCQUNYdEYsWUFBWUMsV0FBVyxDQUFDOzRCQUNwQitCLE9BQU87NEJBQ1BMLE1BQU07Z0NBQUVNLFNBQVM7NEJBQWE7d0JBQ2xDO29CQUNKO29CQUNBLE9BQU9xRDtnQkFDWDtZQUNKO3lDQUFJO1FBQUN2RDtRQUFTd0M7S0FBUTtJQUN0QixPQUNBLG1CQUFtQjtJQUNuQmxHLHNEQUFJQSxDQUFDb0MsZUFBZThFLFFBQVEsRUFBRTtRQUFFekUsT0FBT0E7UUFBT21ELFVBQVVBO0lBQVM7QUFDckUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ob2h1eTg1Mi9Eb2N1bWVudHMvejc2LWFwcHMvbm9kZV9tb2R1bGVzL25leHQtYXV0aC9yZWFjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBOZXh0QXV0aC5qcyBpcyB0aGUgb2ZmaWNpYWwgaW50ZWdyYXRpb24gb2YgQXV0aC5qcyBmb3IgTmV4dC5qcyBhcHBsaWNhdGlvbnMuIEl0IHN1cHBvcnRzIGJvdGhcbiAqIFtDbGllbnQgQ29tcG9uZW50c10oaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL2NsaWVudC1jb21wb25lbnRzKSBhbmQgdGhlXG4gKiBbUGFnZXMgUm91dGVyXShodHRwczovL25leHRqcy5vcmcvZG9jcy9wYWdlcykuIEl0IGluY2x1ZGVzIG1ldGhvZHMgZm9yIHNpZ25pbmcgaW4sIHNpZ25pbmcgb3V0LCBob29rcywgYW5kIGEgUmVhY3RcbiAqIENvbnRleHQgcHJvdmlkZXIgdG8gd3JhcCB5b3VyIGFwcGxpY2F0aW9uIGFuZCBtYWtlIHNlc3Npb24gZGF0YSBhdmFpbGFibGUgYW55d2hlcmUuXG4gKlxuICogRm9yIHVzZSBpbiBbU2VydmVyIEFjdGlvbnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9zZXJ2ZXItYWN0aW9ucyksIGNoZWNrIG91dCBbdGhlc2UgbWV0aG9kc10oaHR0cHM6Ly9hdXRoanMuZGV2L2d1aWRlcy91cGdyYWRlLXRvLXY1I21ldGhvZHMpXG4gKlxuICogQG1vZHVsZSByZWFjdFxuICovXG5cInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGFwaUJhc2VVcmwsIENsaWVudFNlc3Npb25FcnJvciwgZmV0Y2hEYXRhLCBub3csIHBhcnNlVXJsLCB1c2VPbmxpbmUsIH0gZnJvbSBcIi4vbGliL2NsaWVudC5qc1wiO1xuLy8gVGhpcyBiZWhhdmlvdXIgbWlycm9ycyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgZm9yIGdldHRpbmcgdGhlIHNpdGUgbmFtZSB0aGF0XG4vLyBoYXBwZW5zIHNlcnZlciBzaWRlIGluIHNlcnZlci9pbmRleC5qc1xuLy8gMS4gQW4gZW1wdHkgdmFsdWUgaXMgbGVnaXRpbWF0ZSB3aGVuIHRoZSBjb2RlIGlzIGJlaW5nIGludm9rZWQgY2xpZW50IHNpZGUgYXNcbi8vICAgIHJlbGF0aXZlIFVSTHMgYXJlIHZhbGlkIGluIHRoYXQgY29udGV4dCBhbmQgc28gZGVmYXVsdHMgdG8gZW1wdHkuXG4vLyAyLiBXaGVuIGludm9rZWQgc2VydmVyIHNpZGUgdGhlIHZhbHVlIGlzIHBpY2tlZCB1cCBmcm9tIGFuIGVudmlyb25tZW50XG4vLyAgICB2YXJpYWJsZSBhbmQgZGVmYXVsdHMgdG8gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcuXG5leHBvcnQgY29uc3QgX19ORVhUQVVUSCA9IHtcbiAgICBiYXNlVXJsOiBwYXJzZVVybChwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwgPz8gcHJvY2Vzcy5lbnYuVkVSQ0VMX1VSTCkub3JpZ2luLFxuICAgIGJhc2VQYXRoOiBwYXJzZVVybChwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwpLnBhdGgsXG4gICAgYmFzZVVybFNlcnZlcjogcGFyc2VVcmwocHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMX0lOVEVSTkFMID8/XG4gICAgICAgIHByb2Nlc3MuZW52Lk5FWFRBVVRIX1VSTCA/P1xuICAgICAgICBwcm9jZXNzLmVudi5WRVJDRUxfVVJMKS5vcmlnaW4sXG4gICAgYmFzZVBhdGhTZXJ2ZXI6IHBhcnNlVXJsKHByb2Nlc3MuZW52Lk5FWFRBVVRIX1VSTF9JTlRFUk5BTCA/PyBwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwpLnBhdGgsXG4gICAgX2xhc3RTeW5jOiAwLFxuICAgIF9zZXNzaW9uOiB1bmRlZmluZWQsXG4gICAgX2dldFNlc3Npb246ICgpID0+IHsgfSxcbn07XG5sZXQgYnJvYWRjYXN0Q2hhbm5lbCA9IG51bGw7XG5mdW5jdGlvbiBnZXROZXdCcm9hZGNhc3RDaGFubmVsKCkge1xuICAgIHJldHVybiBuZXcgQnJvYWRjYXN0Q2hhbm5lbChcIm5leHQtYXV0aFwiKTtcbn1cbmZ1bmN0aW9uIGJyb2FkY2FzdCgpIHtcbiAgICBpZiAodHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiAoKSA9PiB7IH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChicm9hZGNhc3RDaGFubmVsID09PSBudWxsKSB7XG4gICAgICAgIGJyb2FkY2FzdENoYW5uZWwgPSBnZXROZXdCcm9hZGNhc3RDaGFubmVsKCk7XG4gICAgfVxuICAgIHJldHVybiBicm9hZGNhc3RDaGFubmVsO1xufVxuLy8gVE9ETzpcbmNvbnN0IGxvZ2dlciA9IHtcbiAgICBkZWJ1ZzogY29uc29sZS5kZWJ1ZyxcbiAgICBlcnJvcjogY29uc29sZS5lcnJvcixcbiAgICB3YXJuOiBjb25zb2xlLndhcm4sXG59O1xuZXhwb3J0IGNvbnN0IFNlc3Npb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dD8uKHVuZGVmaW5lZCk7XG4vKipcbiAqIFJlYWN0IEhvb2sgdGhhdCBnaXZlcyB5b3UgYWNjZXNzIHRvIHRoZSBsb2dnZWQgaW4gdXNlcidzIHNlc3Npb24gZGF0YSBhbmQgbGV0cyB5b3UgbW9kaWZ5IGl0LlxuICpcbiAqIDo6OmluZm9cbiAqIGB1c2VTZXNzaW9uYCBpcyBmb3IgY2xpZW50LXNpZGUgdXNlIG9ubHkgYW5kIHdoZW4gdXNpbmcgW05leHQuanMgQXBwIFJvdXRlciAoYGFwcC9gKV0oaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC0xMy00I25leHRqcy1hcHAtcm91dGVyKSB5b3Ugc2hvdWxkIHByZWZlciB0aGUgYGF1dGgoKWAgZXhwb3J0LlxuICogOjo6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZXNzaW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIVNlc3Npb25Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0IENvbnRleHQgaXMgdW5hdmFpbGFibGUgaW4gU2VydmVyIENvbXBvbmVudHNcIik7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgU2F0aXNmeSBUUyBpZiBicmFuY2ggb24gbGluZSBiZWxvd1xuICAgIGNvbnN0IHZhbHVlID0gUmVhY3QudXNlQ29udGV4dChTZXNzaW9uQ29udGV4dCk7XG4gICAgaWYgKCF2YWx1ZSAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW25leHQtYXV0aF06IGB1c2VTZXNzaW9uYCBtdXN0IGJlIHdyYXBwZWQgaW4gYSA8U2Vzc2lvblByb3ZpZGVyIC8+XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IHJlcXVpcmVkLCBvblVuYXV0aGVudGljYXRlZCB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICBjb25zdCByZXF1aXJlZEFuZE5vdExvYWRpbmcgPSByZXF1aXJlZCAmJiB2YWx1ZS5zdGF0dXMgPT09IFwidW5hdXRoZW50aWNhdGVkXCI7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHJlcXVpcmVkQW5kTm90TG9hZGluZykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7X19ORVhUQVVUSC5iYXNlUGF0aH0vc2lnbmluPyR7bmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IFwiU2Vzc2lvblJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tVcmw6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgfSl9YDtcbiAgICAgICAgICAgIGlmIChvblVuYXV0aGVudGljYXRlZClcbiAgICAgICAgICAgICAgICBvblVuYXV0aGVudGljYXRlZCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICB9XG4gICAgfSwgW3JlcXVpcmVkQW5kTm90TG9hZGluZywgb25VbmF1dGhlbnRpY2F0ZWRdKTtcbiAgICBpZiAocmVxdWlyZWRBbmROb3RMb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB2YWx1ZS5kYXRhLFxuICAgICAgICAgICAgdXBkYXRlOiB2YWx1ZS51cGRhdGUsXG4gICAgICAgICAgICBzdGF0dXM6IFwibG9hZGluZ1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2Vzc2lvbihwYXJhbXMpIHtcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgZmV0Y2hEYXRhKFwic2Vzc2lvblwiLCBfX05FWFRBVVRILCBsb2dnZXIsIHBhcmFtcyk7XG4gICAgaWYgKHBhcmFtcz8uYnJvYWRjYXN0ID8/IHRydWUpIHtcbiAgICAgICAgY29uc3QgYnJvYWRjYXN0Q2hhbm5lbCA9IGdldE5ld0Jyb2FkY2FzdENoYW5uZWwoKTtcbiAgICAgICAgYnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBldmVudDogXCJzZXNzaW9uXCIsXG4gICAgICAgICAgICBkYXRhOiB7IHRyaWdnZXI6IFwiZ2V0U2Vzc2lvblwiIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2Vzc2lvbjtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBDcm9zcy1TaXRlIFJlcXVlc3QgRm9yZ2VyeSBUb2tlbiAoQ1NSRiBUb2tlbilcbiAqIHJlcXVpcmVkIHRvIG1ha2UgcmVxdWVzdHMgdGhhdCBjaGFuZ2VzIHN0YXRlLiAoZS5nLiBzaWduaW5nIGluIG9yIG91dCwgb3IgdXBkYXRpbmcgdGhlIHNlc3Npb24pLlxuICpcbiAqIFtDU1JGIFByZXZlbnRpb246IERvdWJsZSBTdWJtaXQgQ29va2llXShodHRwczovL2NoZWF0c2hlZXRzZXJpZXMub3dhc3Aub3JnL2NoZWF0c2hlZXRzL0Nyb3NzLVNpdGVfUmVxdWVzdF9Gb3JnZXJ5X1ByZXZlbnRpb25fQ2hlYXRfU2hlZXQuaHRtbCNkb3VibGUtc3VibWl0LWNvb2tpZSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENzcmZUb2tlbigpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoRGF0YShcImNzcmZcIiwgX19ORVhUQVVUSCwgbG9nZ2VyKTtcbiAgICByZXR1cm4gcmVzcG9uc2U/LmNzcmZUb2tlbiA/PyBcIlwiO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgY2xpZW50LXNhZmUgY29uZmlndXJhdGlvbiBvYmplY3Qgb2YgdGhlIGN1cnJlbnRseVxuICogYXZhaWxhYmxlIHByb3ZpZGVycy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByb3ZpZGVycygpIHtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKFwicHJvdmlkZXJzXCIsIF9fTkVYVEFVVEgsIGxvZ2dlcik7XG59XG4vKipcbiAqIEluaXRpYXRlIGEgc2lnbmluIGZsb3cgb3Igc2VuZCB0aGUgdXNlciB0byB0aGUgc2lnbmluIHBhZ2UgbGlzdGluZyBhbGwgcG9zc2libGUgcHJvdmlkZXJzLlxuICogSGFuZGxlcyBDU1JGIHByb3RlY3Rpb24uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduSW4ocHJvdmlkZXIsIG9wdGlvbnMsIGF1dGhvcml6YXRpb25QYXJhbXMpIHtcbiAgICBjb25zdCB7IHJlZGlyZWN0ID0gdHJ1ZSB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICBjb25zdCByZWRpcmVjdFRvID0gb3B0aW9ucz8ucmVkaXJlY3RUbyA/PyBvcHRpb25zPy5jYWxsYmFja1VybCA/PyB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICBjb25zdCBiYXNlVXJsID0gYXBpQmFzZVVybChfX05FWFRBVVRIKTtcbiAgICBjb25zdCBwcm92aWRlcnMgPSBhd2FpdCBnZXRQcm92aWRlcnMoKTtcbiAgICBpZiAoIXByb3ZpZGVycykge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGAke2Jhc2VVcmx9L2Vycm9yYDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXByb3ZpZGVyIHx8ICEocHJvdmlkZXIgaW4gcHJvdmlkZXJzKSkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGAke2Jhc2VVcmx9L3NpZ25pbj8ke25ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgY2FsbGJhY2tVcmw6IHJlZGlyZWN0VG8sXG4gICAgICAgIH0pfWA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNDcmVkZW50aWFscyA9IHByb3ZpZGVyc1twcm92aWRlcl0udHlwZSA9PT0gXCJjcmVkZW50aWFsc1wiO1xuICAgIGNvbnN0IGlzRW1haWwgPSBwcm92aWRlcnNbcHJvdmlkZXJdLnR5cGUgPT09IFwiZW1haWxcIjtcbiAgICBjb25zdCBpc1N1cHBvcnRpbmdSZXR1cm4gPSBpc0NyZWRlbnRpYWxzIHx8IGlzRW1haWw7XG4gICAgY29uc3Qgc2lnbkluVXJsID0gYCR7YmFzZVVybH0vJHtpc0NyZWRlbnRpYWxzID8gXCJjYWxsYmFja1wiIDogXCJzaWduaW5cIn0vJHtwcm92aWRlcn1gO1xuICAgIGNvbnN0IGNzcmZUb2tlbiA9IGF3YWl0IGdldENzcmZUb2tlbigpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke3NpZ25JblVybH0/JHtuZXcgVVJMU2VhcmNoUGFyYW1zKGF1dGhvcml6YXRpb25QYXJhbXMpfWAsIHtcbiAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgICAgICAgICAgIFwiWC1BdXRoLVJldHVybi1SZWRpcmVjdFwiOiBcIjFcIixcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBib2R5OiBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBjc3JmVG9rZW4sXG4gICAgICAgICAgICBjYWxsYmFja1VybDogcmVkaXJlY3RUbyxcbiAgICAgICAgfSksXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgLy8gVE9ETzogRG8gbm90IHJlZGlyZWN0IGZvciBDcmVkZW50aWFscyBhbmQgRW1haWwgcHJvdmlkZXJzIGJ5IGRlZmF1bHQgaW4gbmV4dCBtYWpvclxuICAgIGlmIChyZWRpcmVjdCB8fCAhaXNTdXBwb3J0aW5nUmV0dXJuKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGRhdGEudXJsID8/IHJlZGlyZWN0VG87XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAvLyBJZiB1cmwgY29udGFpbnMgYSBoYXNoLCB0aGUgYnJvd3NlciBkb2VzIG5vdCByZWxvYWQgdGhlIHBhZ2UuIFdlIHJlbG9hZCBtYW51YWxseVxuICAgICAgICBpZiAodXJsLmluY2x1ZGVzKFwiI1wiKSlcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IG5ldyBVUkwoZGF0YS51cmwpLnNlYXJjaFBhcmFtcy5nZXQoXCJlcnJvclwiKTtcbiAgICBjb25zdCBjb2RlID0gbmV3IFVSTChkYXRhLnVybCkuc2VhcmNoUGFyYW1zLmdldChcImNvZGVcIik7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgICBhd2FpdCBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHsgZXZlbnQ6IFwic3RvcmFnZVwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcixcbiAgICAgICAgY29kZSxcbiAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgICBvazogcmVzLm9rLFxuICAgICAgICB1cmw6IGVycm9yID8gbnVsbCA6IGRhdGEudXJsLFxuICAgIH07XG59XG4vKipcbiAqIEluaXRpYXRlIGEgc2lnbm91dCwgYnkgZGVzdHJveWluZyB0aGUgY3VycmVudCBzZXNzaW9uLlxuICogSGFuZGxlcyBDU1JGIHByb3RlY3Rpb24uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduT3V0KG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWRpcmVjdFRvID0gb3B0aW9ucz8ucmVkaXJlY3RUbyA/PyBvcHRpb25zPy5jYWxsYmFja1VybCA/PyB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICBjb25zdCBiYXNlVXJsID0gYXBpQmFzZVVybChfX05FWFRBVVRIKTtcbiAgICBjb25zdCBjc3JmVG9rZW4gPSBhd2FpdCBnZXRDc3JmVG9rZW4oKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsfS9zaWdub3V0YCwge1xuICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgICAgICAgICAgXCJYLUF1dGgtUmV0dXJuLVJlZGlyZWN0XCI6IFwiMVwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgY3NyZlRva2VuLCBjYWxsYmFja1VybDogcmVkaXJlY3RUbyB9KSxcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBicm9hZGNhc3QoKS5wb3N0TWVzc2FnZSh7IGV2ZW50OiBcInNlc3Npb25cIiwgZGF0YTogeyB0cmlnZ2VyOiBcInNpZ25vdXRcIiB9IH0pO1xuICAgIGlmIChvcHRpb25zPy5yZWRpcmVjdCA/PyB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGRhdGEudXJsID8/IHJlZGlyZWN0VG87XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAvLyBJZiB1cmwgY29udGFpbnMgYSBoYXNoLCB0aGUgYnJvd3NlciBkb2VzIG5vdCByZWxvYWQgdGhlIHBhZ2UuIFdlIHJlbG9hZCBtYW51YWxseVxuICAgICAgICBpZiAodXJsLmluY2x1ZGVzKFwiI1wiKSlcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IF9fTkVYVEFVVEguX2dldFNlc3Npb24oeyBldmVudDogXCJzdG9yYWdlXCIgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIFtSZWFjdCBDb250ZXh0XShodHRwczovL3JlYWN0LmRldi9sZWFybi9wYXNzaW5nLWRhdGEtZGVlcGx5LXdpdGgtY29udGV4dCkgcHJvdmlkZXIgdG8gd3JhcCB0aGUgYXBwIChgcGFnZXMvYCkgdG8gbWFrZSBzZXNzaW9uIGRhdGEgYXZhaWxhYmxlIGFueXdoZXJlLlxuICpcbiAqIFdoZW4gdXNlZCwgdGhlIHNlc3Npb24gc3RhdGUgaXMgYXV0b21hdGljYWxseSBzeW5jaHJvbml6ZWQgYWNyb3NzIGFsbCBvcGVuIHRhYnMvd2luZG93cyBhbmQgdGhleSBhcmUgYWxsIHVwZGF0ZWQgd2hlbmV2ZXIgdGhleSBnYWluIG9yIGxvc2UgZm9jdXNcbiAqIG9yIHRoZSBzdGF0ZSBjaGFuZ2VzIChlLmcuIGEgdXNlciBzaWducyBpbiBvciBvdXQpIHdoZW4ge0BsaW5rIFNlc3Npb25Qcm92aWRlclByb3BzLnJlZmV0Y2hPbldpbmRvd0ZvY3VzfSBpcyBgdHJ1ZWAuXG4gKlxuICogOjo6aW5mb1xuICogYFNlc3Npb25Qcm92aWRlcmAgaXMgZm9yIGNsaWVudC1zaWRlIHVzZSBvbmx5IGFuZCB3aGVuIHVzaW5nIFtOZXh0LmpzIEFwcCBSb3V0ZXIgKGBhcHAvYCldKGh0dHBzOi8vbmV4dGpzLm9yZy9ibG9nL25leHQtMTMtNCNuZXh0anMtYXBwLXJvdXRlcikgeW91IHNob3VsZCBwcmVmZXIgdGhlIGBhdXRoKClgIGV4cG9ydC5cbiAqIDo6OlxuICovXG5leHBvcnQgZnVuY3Rpb24gU2Vzc2lvblByb3ZpZGVyKHByb3BzKSB7XG4gICAgaWYgKCFTZXNzaW9uQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdCBDb250ZXh0IGlzIHVuYXZhaWxhYmxlIGluIFNlcnZlciBDb21wb25lbnRzXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGNoaWxkcmVuLCBiYXNlUGF0aCwgcmVmZXRjaEludGVydmFsLCByZWZldGNoV2hlbk9mZmxpbmUgfSA9IHByb3BzO1xuICAgIGlmIChiYXNlUGF0aClcbiAgICAgICAgX19ORVhUQVVUSC5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICAgIC8qKlxuICAgICAqIElmIHNlc3Npb24gd2FzIGBudWxsYCwgdGhlcmUgd2FzIGFuIGF0dGVtcHQgdG8gZmV0Y2ggaXQsXG4gICAgICogYnV0IGl0IGZhaWxlZCwgYnV0IHdlIHN0aWxsIHRyZWF0IGl0IGFzIGEgdmFsaWQgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBjb25zdCBoYXNJbml0aWFsU2Vzc2lvbiA9IHByb3BzLnNlc3Npb24gIT09IHVuZGVmaW5lZDtcbiAgICAvKiogSWYgc2Vzc2lvbiB3YXMgcGFzc2VkLCBpbml0aWFsaXplIGFzIGFscmVhZHkgc3luY2VkICovXG4gICAgX19ORVhUQVVUSC5fbGFzdFN5bmMgPSBoYXNJbml0aWFsU2Vzc2lvbiA/IG5vdygpIDogMDtcbiAgICBjb25zdCBbc2Vzc2lvbiwgc2V0U2Vzc2lvbl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmIChoYXNJbml0aWFsU2Vzc2lvbilcbiAgICAgICAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPSBwcm9wcy5zZXNzaW9uO1xuICAgICAgICByZXR1cm4gcHJvcHMuc2Vzc2lvbjtcbiAgICB9KTtcbiAgICAvKiogSWYgc2Vzc2lvbiB3YXMgcGFzc2VkLCBpbml0aWFsaXplIGFzIG5vdCBsb2FkaW5nICovXG4gICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gUmVhY3QudXNlU3RhdGUoIWhhc0luaXRpYWxTZXNzaW9uKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBfX05FWFRBVVRILl9nZXRTZXNzaW9uID0gYXN5bmMgKHsgZXZlbnQgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VFdmVudCA9IGV2ZW50ID09PSBcInN0b3JhZ2VcIjtcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIHVwZGF0ZSBpZiB3ZSBkb24ndCBoYXZlIGEgY2xpZW50IHNlc3Npb24geWV0XG4gICAgICAgICAgICAgICAgLy8gb3IgaWYgdGhlcmUgYXJlIGV2ZW50cyBmcm9tIG90aGVyIHRhYnMvd2luZG93c1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlRXZlbnQgfHwgX19ORVhUQVVUSC5fc2Vzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9fTkVYVEFVVEguX2xhc3RTeW5jID0gbm93KCk7XG4gICAgICAgICAgICAgICAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPSBhd2FpdCBnZXRTZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyb2FkY2FzdDogIXN0b3JhZ2VFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlc3Npb24oX19ORVhUQVVUSC5fc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHRpbWUgZGVmaW5lZCBmb3Igd2hlbiBhIHNlc3Npb24gc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgICAgICAgICAgICAvLyBzdGFsZSwgdGhlbiBpdCdzIG9rYXkgdG8gdXNlIHRoZSB2YWx1ZSB3ZSBoYXZlIHVudGlsIGFuIGV2ZW50IGlzXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlcmVkIHdoaWNoIHVwZGF0ZXMgaXRcbiAgICAgICAgICAgICAgICAhZXZlbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNsaWVudCBkb2Vzbid0IGhhdmUgYSBzZXNzaW9uIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBjYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgdG8gY2hlY2sgaWYgaXQgZG9lcyAoaWYgdGhleSBoYXZlIHNpZ25lZCBpbiB2aWEgYW5vdGhlclxuICAgICAgICAgICAgICAgICAgICAvLyB0YWIgb3Igd2luZG93IHRoYXQgd2lsbCBjb21lIHRocm91Z2ggYXMgYSBcInN0cm9hZ2VcIiBldmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVudCBhbnl3YXkpXG4gICAgICAgICAgICAgICAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgZWFybHkgaWYgdGhlIGNsaWVudCBzZXNzaW9uIGlzIG5vdCBzdGFsZSB5ZXRcbiAgICAgICAgICAgICAgICAgICAgbm93KCkgPCBfX05FWFRBVVRILl9sYXN0U3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFuIGV2ZW50IG9yIHNlc3Npb24gc3RhbGVuZXNzIG9jY3VycmVkLCB1cGRhdGUgdGhlIGNsaWVudCBzZXNzaW9uLlxuICAgICAgICAgICAgICAgIF9fTkVYVEFVVEguX2xhc3RTeW5jID0gbm93KCk7XG4gICAgICAgICAgICAgICAgX19ORVhUQVVUSC5fc2Vzc2lvbiA9IGF3YWl0IGdldFNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBzZXRTZXNzaW9uKF9fTkVYVEFVVEguX3Nlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKG5ldyBDbGllbnRTZXNzaW9uRXJyb3IoZXJyb3IubWVzc2FnZSwgZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfX05FWFRBVVRILl9nZXRTZXNzaW9uKCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9IDA7XG4gICAgICAgICAgICBfX05FWFRBVVRILl9zZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbiA9ICgpID0+IHsgfTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gKCkgPT4gX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7IGV2ZW50OiBcInN0b3JhZ2VcIiB9KTtcbiAgICAgICAgLy8gTGlzdGVuIGZvciBzdG9yYWdlIGV2ZW50cyBhbmQgdXBkYXRlIHNlc3Npb24gaWYgZXZlbnQgZmlyZWQgZnJvbVxuICAgICAgICAvLyBhbm90aGVyIHdpbmRvdyAoYnV0IHN1cHByZXNzIGZpcmluZyBhbm90aGVyIGV2ZW50IHRvIGF2b2lkIGEgbG9vcClcbiAgICAgICAgLy8gRmV0Y2ggbmV3IHNlc3Npb24gZGF0YSBidXQgdGVsbCBpdCB0byBub3QgdG8gZmlyZSBhbm90aGVyIGV2ZW50IHRvXG4gICAgICAgIC8vIGF2b2lkIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgIC8vIE5vdGU6IFdlIGNvdWxkIHBhc3Mgc2Vzc2lvbiBkYXRhIHRocm91Z2ggYW5kIGRvIHNvbWV0aGluZyBsaWtlXG4gICAgICAgIC8vIGBzZXREYXRhKG1lc3NhZ2UuZGF0YSlgIGJ1dCB0aGF0IGNhbiBjYXVzZSBwcm9ibGVtcyBkZXBlbmRpbmdcbiAgICAgICAgLy8gb24gaG93IHRoZSBzZXNzaW9uIG9iamVjdCBpcyBiZWluZyB1c2VkIGluIHRoZSBjbGllbnQ7IGl0IGlzXG4gICAgICAgIC8vIG1vcmUgcm9idXN0IHRvIGhhdmUgZWFjaCB3aW5kb3cvdGFiIGZldGNoIGl0J3Mgb3duIGNvcHkgb2YgdGhlXG4gICAgICAgIC8vIHNlc3Npb24gb2JqZWN0IHJhdGhlciB0aGFuIHNoYXJlIGl0IGFjcm9zcyBpbnN0YW5jZXMuXG4gICAgICAgIGJyb2FkY2FzdCgpLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBicm9hZGNhc3QoKS5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGUpO1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlZmV0Y2hPbldpbmRvd0ZvY3VzID0gdHJ1ZSB9ID0gcHJvcHM7XG4gICAgICAgIC8vIExpc3RlbiBmb3Igd2hlbiB0aGUgcGFnZSBpcyB2aXNpYmxlLCBpZiB0aGUgdXNlciBzd2l0Y2hlcyB0YWJzXG4gICAgICAgIC8vIGFuZCBtYWtlcyBvdXIgdGFiIHZpc2libGUgYWdhaW4sIHJlLWZldGNoIHRoZSBzZXNzaW9uLCBidXQgb25seSBpZlxuICAgICAgICAvLyB0aGlzIGZlYXR1cmUgaXMgbm90IGRpc2FibGVkLlxuICAgICAgICBjb25zdCB2aXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWZldGNoT25XaW5kb3dGb2N1cyAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKVxuICAgICAgICAgICAgICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24oeyBldmVudDogXCJ2aXNpYmlsaXR5Y2hhbmdlXCIgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHZpc2liaWxpdHlIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB2aXNpYmlsaXR5SGFuZGxlciwgZmFsc2UpO1xuICAgIH0sIFtwcm9wcy5yZWZldGNoT25XaW5kb3dGb2N1c10pO1xuICAgIGNvbnN0IGlzT25saW5lID0gdXNlT25saW5lKCk7XG4gICAgLy8gVE9ETzogRmxpcCB0aGlzIGJlaGF2aW9yIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgIGNvbnN0IHNob3VsZFJlZmV0Y2ggPSByZWZldGNoV2hlbk9mZmxpbmUgIT09IGZhbHNlIHx8IGlzT25saW5lO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChyZWZldGNoSW50ZXJ2YWwgJiYgc2hvdWxkUmVmZXRjaCkge1xuICAgICAgICAgICAgY29uc3QgcmVmZXRjaEludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKF9fTkVYVEFVVEguX3Nlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7IGV2ZW50OiBcInBvbGxcIiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZWZldGNoSW50ZXJ2YWwgKiAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKHJlZmV0Y2hJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgfVxuICAgIH0sIFtyZWZldGNoSW50ZXJ2YWwsIHNob3VsZFJlZmV0Y2hdKTtcbiAgICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgZGF0YTogc2Vzc2lvbixcbiAgICAgICAgc3RhdHVzOiBsb2FkaW5nXG4gICAgICAgICAgICA/IFwibG9hZGluZ1wiXG4gICAgICAgICAgICA6IHNlc3Npb25cbiAgICAgICAgICAgICAgICA/IFwiYXV0aGVudGljYXRlZFwiXG4gICAgICAgICAgICAgICAgOiBcInVuYXV0aGVudGljYXRlZFwiLFxuICAgICAgICBhc3luYyB1cGRhdGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGxvYWRpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Nlc3Npb24gPSBhd2FpdCBmZXRjaERhdGEoXCJzZXNzaW9uXCIsIF9fTkVYVEFVVEgsIGxvZ2dlciwgdHlwZW9mIGRhdGEgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogeyBib2R5OiB7IGNzcmZUb2tlbjogYXdhaXQgZ2V0Q3NyZlRva2VuKCksIGRhdGEgfSB9KTtcbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKG5ld1Nlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBzZXRTZXNzaW9uKG5ld1Nlc3Npb24pO1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdCgpLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwic2Vzc2lvblwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHRyaWdnZXI6IFwiZ2V0U2Vzc2lvblwiIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3U2Vzc2lvbjtcbiAgICAgICAgfSxcbiAgICB9KSwgW3Nlc3Npb24sIGxvYWRpbmddKTtcbiAgICByZXR1cm4gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBfanN4KFNlc3Npb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cbiJdLCJuYW1lcyI6WyJqc3giLCJfanN4IiwiUmVhY3QiLCJhcGlCYXNlVXJsIiwiQ2xpZW50U2Vzc2lvbkVycm9yIiwiZmV0Y2hEYXRhIiwibm93IiwicGFyc2VVcmwiLCJ1c2VPbmxpbmUiLCJfX05FWFRBVVRIIiwiYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUQVVUSF9VUkwiLCJWRVJDRUxfVVJMIiwib3JpZ2luIiwiYmFzZVBhdGgiLCJwYXRoIiwiYmFzZVVybFNlcnZlciIsIk5FWFRBVVRIX1VSTF9JTlRFUk5BTCIsImJhc2VQYXRoU2VydmVyIiwiX2xhc3RTeW5jIiwiX3Nlc3Npb24iLCJ1bmRlZmluZWQiLCJfZ2V0U2Vzc2lvbiIsImJyb2FkY2FzdENoYW5uZWwiLCJnZXROZXdCcm9hZGNhc3RDaGFubmVsIiwiQnJvYWRjYXN0Q2hhbm5lbCIsImJyb2FkY2FzdCIsInBvc3RNZXNzYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsb2dnZXIiLCJkZWJ1ZyIsImNvbnNvbGUiLCJlcnJvciIsIndhcm4iLCJTZXNzaW9uQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VTZXNzaW9uIiwib3B0aW9ucyIsIkVycm9yIiwidmFsdWUiLCJ1c2VDb250ZXh0IiwicmVxdWlyZWQiLCJvblVuYXV0aGVudGljYXRlZCIsInJlcXVpcmVkQW5kTm90TG9hZGluZyIsInN0YXR1cyIsInVzZUVmZmVjdCIsInVybCIsIlVSTFNlYXJjaFBhcmFtcyIsImNhbGxiYWNrVXJsIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiZGF0YSIsInVwZGF0ZSIsImdldFNlc3Npb24iLCJwYXJhbXMiLCJzZXNzaW9uIiwiZXZlbnQiLCJ0cmlnZ2VyIiwiZ2V0Q3NyZlRva2VuIiwicmVzcG9uc2UiLCJjc3JmVG9rZW4iLCJnZXRQcm92aWRlcnMiLCJzaWduSW4iLCJwcm92aWRlciIsImF1dGhvcml6YXRpb25QYXJhbXMiLCJyZWRpcmVjdCIsInJlZGlyZWN0VG8iLCJwcm92aWRlcnMiLCJpc0NyZWRlbnRpYWxzIiwidHlwZSIsImlzRW1haWwiLCJpc1N1cHBvcnRpbmdSZXR1cm4iLCJzaWduSW5VcmwiLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwianNvbiIsImluY2x1ZGVzIiwicmVsb2FkIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwiY29kZSIsIm9rIiwic2lnbk91dCIsIlNlc3Npb25Qcm92aWRlciIsInByb3BzIiwiY2hpbGRyZW4iLCJyZWZldGNoSW50ZXJ2YWwiLCJyZWZldGNoV2hlbk9mZmxpbmUiLCJoYXNJbml0aWFsU2Vzc2lvbiIsInNldFNlc3Npb24iLCJ1c2VTdGF0ZSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwic3RvcmFnZUV2ZW50IiwibWVzc2FnZSIsImhhbmRsZSIsInJlZmV0Y2hPbldpbmRvd0ZvY3VzIiwidmlzaWJpbGl0eUhhbmRsZXIiLCJkb2N1bWVudCIsInZpc2liaWxpdHlTdGF0ZSIsImlzT25saW5lIiwic2hvdWxkUmVmZXRjaCIsInJlZmV0Y2hJbnRlcnZhbFRpbWVyIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidXNlTWVtbyIsIm5ld1Nlc3Npb24iLCJQcm92aWRlciJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next-auth/react.js\n");

/***/ })

};
;